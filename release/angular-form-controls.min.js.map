{"version":3,"sources":["angular-form-controls.min.js","check-box.js","check-boxes.js","form-controls.js","radio-buttons.js","select-box.js","type-ahead.js"],"names":["window","angular","undefined","module","component","template","require","ngModel","transclude","bindings","model","onChange","isInverse","isDisabled","controller","$element","$formControls","$ctrl","this","$onInit","classes","className","addClass","$label","find","on","focus","$isEmpty","$onChanges","changes","$validate","hasChanged","$setDirty","toggle","event","defaultPrevented","value","isChecked","options","min","max","$attrs","$log","getTrackingValue","option","index","trackBy","isObject","warn","getLabelValue","labelBy","isArray","length","optionValue","modelValue","asObject","$validators","$error","required","$$setOptions","allowInvalid","$options","createChild","split","set","Set","Array","from","values","getLabel","map","item","checked","i","findIndex","splice","push","factory","previousValue","currentValue","equals","isNullable","nullValue","nullLabel","getModelValue","isSelected","select","inputClass","filter","hasSpinner","$filter","$scope","$document","$timeout","$window","debounce","func","delay","timeout","wrapper","clearTimeout","setTimeout","isTextInput","keyCode","documentClickHandler","isShowingOptions","contains","target","$apply","hideOptions","bind","preventDefault","stopPropagation","findScrollableParent","$child","$parent","parent","style","getComputedStyle","tagName","overflowY","findOffset","node","relativeNode","offset","offsetTop","offsetParent","ensureDropdownInView","$container","$input","next","height","clientHeight","scroll","scrollTop","bottom","diff","ensureSelectionInView","selectionIndex","children","cTop","cBottom","eTop","eBottom","moveSelectionUp","oldIndex","moveSelectionDown","findOption","phrase","ENTER","ESC","UP","DOWN","clearPhrase","selectBoxClass","$onDestroy","off","indexOf","keydown","showOptions","confirmSelection","char","String","fromCharCode","selectByInput","getSelectedLabel","toggleOptions","hasOptions","toLowerCase","regex","RegExp","label","match","o","leaveOpen","setSelection","isSelection","placeholder","onSearch","onQuery","minLength","allowNew","$q","isControlInput","keys","LEFT","RIGHT","TAB","SHIFT","CTRL","ALT","CAPSLOCK","CMDLEFT","CMDRIGHT","isShowingResults","hideResults","results","searchOptions","resolve","items","test","currentSearch","lastProcessedSearch","pendingSearch","attr","typeAheadClass","isSearching","searchQuery","showResults","keyup","trim","lastValue","cancel","search","hasResults","clearResults","clearSelection","_this","doSearch","_this2","reject","then"],"mappings":"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","file":"angular-form-controls.min.js","sourcesContent":["/**\n * @meanie/angular-form-controls * https://github.com/meanie/angular-form-controls\n *\n * Copyright (c) 2020 Adam Reis <adam@reis.nz>\n * License: MIT\n */\n(function (window, angular, undefined) {\n  'use strict';\n\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('CheckBox.Component', [])\n\n  /**\n   * Checkbox component\n   */\n  .component('checkBox', {\n    template: '<label class=\"CheckBox {{$ctrl.classes}}\"\\n      ng-transclude\\n      ng-click=\"$ctrl.toggle($event)\"\\n      ng-class=\"{checked: $ctrl.isChecked(), disabled: $ctrl.isDisabled}\"\\n    ></label>',\n    require: {\n      ngModel: 'ngModel'\n    },\n    transclude: true,\n    bindings: {\n      model: '<ngModel',\n      onChange: '&',\n      isInverse: '<isInverse',\n      isDisabled: '<ngDisabled'\n    },\n\n    /**\n     * Component controller\n     */\n    controller: ['$element', '$formControls', function controller($element, $formControls) {\n\n      //Get instance\n      var $ctrl = this;\n\n      /**\n       * On init\n       */\n      this.$onInit = function () {\n\n        //Propagate classes\n        this.classes = $element[0].className;\n        $element[0].className = '';\n\n        //Add checkbox wrapper class to parent component\n        $element.addClass('CheckBoxWrapper');\n\n        //Find label\n        var $label = $element.find('label');\n\n        //Propagate focus\n        $element.on('focus', function () {\n          $label[0].focus();\n        });\n\n        //Empty check override in order for ng-required to work properly\n        this.ngModel.$isEmpty = function () {\n          if ($ctrl.isInverse) {\n            return !!$ctrl.model;\n          }\n          return !$ctrl.model;\n        };\n      };\n\n      /**\n       * On change\n       */\n      this.$onChanges = function (changes) {\n\n        //Validate and mark as dirty if needed\n        if (changes.model) {\n          this.ngModel.$validate();\n          if ($formControls.hasChanged(changes.model)) {\n            this.ngModel.$setDirty();\n          }\n        }\n      };\n\n      /**\n       * Toggle\n       */\n      this.toggle = function (event) {\n\n        //Don't toggle when disabled or event default prevented\n        if (this.isDisabled || event.defaultPrevented) {\n          return;\n        }\n\n        //Get boolean value and call on change handler\n        var value = !this.model;\n        this.onChange({ value: value });\n      };\n\n      /**\n       * Check if checked\n       */\n      this.isChecked = function () {\n        return this.isInverse ? !this.model : !!this.model;\n      };\n    }]\n  });\n})(window, window.angular);\n(function (window, angular, undefined) {\n  'use strict';\n\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('CheckBoxes.Component', [])\n\n  /**\n   * Checkboxes component\n   */\n  .component('checkBoxes', {\n    template: '<div class=\"CheckBoxGroup {{$ctrl.classes}}\">\\n      <label class=\"CheckBox\"\\n        ng-repeat=\"option in $ctrl.options\"\\n        ng-click=\"$ctrl.toggle(option, $index)\"\\n        ng-class=\"{checked: $ctrl.isChecked(option, $index), disabled: $ctrl.isDisabled}\"\\n      >{{$ctrl.getLabel(option)}}</label>\\n    </div>',\n    require: {\n      ngModel: 'ngModel'\n    },\n    bindings: {\n      model: '<ngModel',\n      options: '<',\n      min: '<',\n      max: '<',\n      onChange: '&',\n      isDisabled: '<ngDisabled'\n    },\n\n    /**\n     * Component controller\n     */\n    controller: ['$element', '$attrs', '$log', '$formControls', function controller($element, $attrs, $log, $formControls) {\n\n      //Helper vars\n      var $ctrl = this;\n      var labelBy = $attrs.labelBy || null;\n      var trackBy = $attrs.trackBy || null;\n      var asObject = $attrs.asObject === 'true';\n\n      /**\n       * Helper to get the tracking value of an option\n       */\n      function getTrackingValue(option, index) {\n\n        //Tracking by index?\n        if (trackBy === '$index') {\n          return index;\n        }\n\n        //Non object? Track by its value\n        if (!angular.isObject(option)) {\n          return option;\n        }\n\n        //Must have tracking property\n        if (!trackBy) {\n          $log.warn('Missing track-by property for check boxes');\n          return null;\n        }\n\n        //Validate property\n        if (typeof option[trackBy] === 'undefined') {\n          $log.warn('Unknown property `' + trackBy + '` for check box tracking');\n          return null;\n        }\n\n        //Return the property\n        return option[trackBy];\n      }\n\n      /**\n       * Get label value of an option\n       */\n      function getLabelValue(option) {\n\n        //Non object? Use its value\n        if (!angular.isObject(option)) {\n          return option;\n        }\n\n        //Must have label property\n        if (!labelBy) {\n          $log.warn('Missing label-by property for check boxes');\n          return '';\n        }\n\n        //Validate property\n        if (typeof option[labelBy] === 'undefined') {\n          $log.warn('Unknown property `' + labelBy + '` for check box label');\n          return '';\n        }\n\n        //Return the property\n        return option[labelBy];\n      }\n\n      /**\n       * Check if a certain option is checked\n       */\n      function isChecked(model, option, index) {\n\n        //Nothing selected?\n        if (!angular.isArray(model) || model.length === 0) {\n          return false;\n        }\n\n        //Get option value\n        var optionValue = getTrackingValue(option, index);\n\n        //See if present in model values\n        var find = model.find(function (model) {\n          var modelValue = getTrackingValue(model, model);\n          return modelValue === optionValue;\n        });\n        return typeof find !== 'undefined';\n      }\n\n      /**\n       * Initialization\n       */\n      this.$onInit = function () {\n\n        //Check configuration\n        if (asObject && trackBy === '$index') {\n          $log.warn('Cannot track check boxes by index if model is an object');\n          asObject = false;\n        }\n\n        //Propagate classes\n        this.classes = $element[0].className;\n        $element[0].className = '';\n\n        //Validation for min/max values\n        this.ngModel.$validators.min = function (modelValue) {\n          if ($ctrl.ngModel.$error.required) {\n            return true;\n          }\n          if (!$ctrl.min || $ctrl.min < 0) {\n            return true;\n          }\n          return !angular.isArray(modelValue) || modelValue.length >= $ctrl.min;\n        };\n        this.ngModel.$validators.max = function (modelValue) {\n          if ($ctrl.ngModel.$error.required) {\n            return true;\n          }\n          if (!$ctrl.max || $ctrl.max < 0) {\n            return true;\n          }\n          return !angular.isArray(modelValue) || modelValue.length <= $ctrl.max;\n        };\n\n        //Empty check override in order for ng-required to work properly\n        this.ngModel.$isEmpty = function () {\n\n          //Needed here to prevent $validate from setting the model to undefined\n          //NOTE: first approach for Angular < 1.6.0\n          if (typeof $ctrl.ngModel.$$setOptions === 'function') {\n            $ctrl.ngModel.$$setOptions({\n              allowInvalid: true\n            });\n          } else {\n            $ctrl.ngModel.$options = $ctrl.ngModel.$options.createChild({\n              allowInvalid: true\n            });\n          }\n\n          //Return check now\n          return !angular.isArray($ctrl.model) || $ctrl.model.length === 0;\n        };\n      };\n\n      /**\n       * On change\n       */\n      this.$onChanges = function (changes) {\n\n        //Must have array as options\n        if (!angular.isArray(this.options)) {\n          if (typeof this.options === 'string') {\n            var options = this.options.split('\\n');\n            var set = new Set(options);\n            this.options = Array.from(set.values());\n          } else {\n            this.options = [];\n          }\n        }\n\n        //Validate and mark as dirty if needed\n        if (changes.model) {\n          this.ngModel.$validate();\n          if ($formControls.hasChanged(changes.model)) {\n            this.ngModel.$setDirty();\n          }\n        }\n      };\n\n      /**\n       * Get label value of an option\n       */\n      this.getLabel = function (option) {\n        return getLabelValue(option);\n      };\n\n      /**\n       * Check if given option is checked\n       */\n      this.isChecked = function (option, index) {\n        return isChecked(this.model, option, index);\n      };\n\n      /**\n       * Toggle an option\n       */\n      this.toggle = function (option, index) {\n\n        //Ignore when disabled\n        if (this.isDisabled) {\n          return;\n        }\n\n        //Initialize value of our model array\n        var value = [];\n        if (angular.isArray(this.model)) {\n          value = this.model.map(function (item) {\n            return item;\n          });\n        }\n\n        //Check if currently checked (use source model) and get the item value\n        var checked = isChecked(value, option, index);\n        var optionValue = getTrackingValue(option, index);\n\n        //If checked, remove from target model, otherwise add\n        if (checked) {\n          var i = value.findIndex(function (model) {\n            var modelValue = getTrackingValue(model, model);\n            return modelValue === optionValue;\n          });\n          value.splice(i, 1);\n        } else {\n          value.push(asObject ? option : optionValue);\n        }\n\n        //Call on change handler\n        this.onChange({ value: value });\n      };\n    }]\n  });\n})(window, window.angular);\n(function (window, angular, undefined) {\n  'use strict';\n\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('FormControls.Component', ['CheckBox.Component', 'CheckBoxes.Component', 'RadioButtons.Component', 'SelectBox.Component', 'TypeAhead.Component'])\n\n  /**\n   * Helper service\n   */\n  .factory('$formControls', function () {\n    return {\n\n      /**\n       * Check if an item value really changed (deep checking with angular.equals)\n       */\n\n      hasChanged: function hasChanged(changes) {\n\n        //Get previous and current value\n        var previousValue = changes.previousValue;\n        var currentValue = changes.currentValue;\n\n        //If unitialized, don't trigger changes\n\n        if (previousValue === 'UNINITIALIZED_VALUE') {\n          return false;\n        }\n\n        //Check if equals\n        return !angular.equals(previousValue, currentValue);\n      }\n    };\n  });\n})(window, window.angular);\n(function (window, angular, undefined) {\n  'use strict';\n\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('RadioButtons.Component', [])\n\n  /**\n   * Radio buttons component\n   */\n  .component('radioButtons', {\n    template: '<div class=\"RadioButtonGroup {{$ctrl.classes}}\">\\n      <label class=\"RadioButton\"\\n        ng-if=\"$ctrl.isNullable\"\\n        ng-click=\"$ctrl.select(null)\"\\n        ng-class=\"{checked: $ctrl.isSelected(null), disabled: $ctrl.isDisabled}\"\\n      >{{$ctrl.nullLabel}}</label>\\n      <label class=\"RadioButton\"\\n        ng-repeat=\"option in $ctrl.options\"\\n        ng-click=\"$ctrl.select(option, $index)\"\\n        ng-class=\"{checked: $ctrl.isSelected(option, $index), disabled: $ctrl.isDisabled}\"\\n      >{{$ctrl.getLabel(option)}}</label>\\n    </div>',\n    require: {\n      ngModel: 'ngModel'\n    },\n    bindings: {\n      model: '<ngModel',\n      options: '<',\n      onChange: '&',\n      isNullable: '<',\n      nullValue: '<',\n      nullLabel: '<',\n      isDisabled: '<ngDisabled'\n    },\n\n    /**\n     * Component controller\n     */\n    controller: ['$element', '$attrs', '$log', '$formControls', function controller($element, $attrs, $log, $formControls) {\n\n      //Helper vars\n      var $ctrl = this;\n      var labelBy = $attrs.labelBy || null;\n      var trackBy = $attrs.trackBy || null;\n      var asObject = $attrs.asObject === 'true';\n\n      /**\n       * Helper to get the tracking value of an option\n       */\n      function getTrackingValue(option, index) {\n\n        //Null value?\n        if (option === null) {\n          return $ctrl.nullValue;\n        }\n\n        //Tracking by index?\n        if (trackBy === '$index') {\n          return index;\n        }\n\n        //Non object? Track by its value\n        if (!angular.isObject(option)) {\n          return option;\n        }\n\n        //Must have tracking property\n        if (!trackBy) {\n          $log.warn('Missing track-by property for radio buttons');\n          return null;\n        }\n\n        //Validate property\n        if (typeof option[trackBy] === 'undefined') {\n          $log.warn('Unknown property `' + trackBy + '` for radio tracking');\n          return null;\n        }\n\n        //Return the property\n        return option[trackBy];\n      }\n\n      /**\n       * Get the model value\n       */\n      function getModelValue(option, index) {\n\n        //If nullable and null option given, return null value\n        if ($ctrl.isNullable && option === null) {\n          return $ctrl.nullValue;\n        }\n\n        //If returning as object, return the selected option\n        if (asObject) {\n          return option;\n        }\n\n        //Otherwise, return the tracking value of the given option\n        return getTrackingValue(option, index);\n      }\n\n      /**\n       * Get label value of an option\n       */\n      function getLabelValue(option) {\n\n        //Null value?\n        if (option === null) {\n          return $ctrl.nullLabel;\n        }\n\n        //Non object? Use its value\n        if (!angular.isObject(option)) {\n          return option;\n        }\n\n        //Must have label property\n        if (!labelBy) {\n          $log.warn('Missing label-by property for selectbox');\n          return '';\n        }\n\n        //Validate property\n        if (typeof option[labelBy] === 'undefined') {\n          $log.warn('Unknown property `' + labelBy + '` for selectbox label');\n          return '';\n        }\n\n        //Return the property\n        return option[labelBy];\n      }\n\n      /**\n       * Check if a certain option is selected\n       */\n      function isSelected(option, index) {\n\n        //Nullable and null value selected?\n        if ($ctrl.isNullable && $ctrl.model === $ctrl.nullValue && option === null) {\n          return true;\n        }\n\n        //Nothing selected?\n        if ($ctrl.model === null) {\n          return false;\n        }\n\n        //Get the model and option values\n        var modelValue = getTrackingValue($ctrl.model, $ctrl.model);\n        var optionValue = getTrackingValue(option, index);\n\n        //Compare the two\n        return modelValue === optionValue;\n      }\n\n      /**\n       * Initialization\n       */\n      this.$onInit = function () {\n\n        //Check configuration\n        if (asObject && trackBy === '$index') {\n          $log.warn('Cannot track radio buttons by index if model is an object');\n          asObject = false;\n        }\n\n        //Propagate classes\n        this.classes = $element[0].className;\n        $element[0].className = '';\n\n        //Empty check override in order for ng-required to work properly\n        this.ngModel.$isEmpty = function () {\n          if ($ctrl.isNullable) {\n            return $ctrl.model === $ctrl.nullValue;\n          }\n          return $ctrl.model === null || $ctrl.model === $ctrl.nullValue || typeof $ctrl.model === 'undefined';\n        };\n      };\n\n      /**\n       * On change\n       */\n      this.$onChanges = function (changes) {\n\n        //Must have array as options\n        if (!angular.isArray(this.options)) {\n          if (typeof this.options === 'string') {\n            var options = this.options.split('\\n');\n            var set = new Set(options);\n            this.options = Array.from(set.values());\n          } else {\n            this.options = [];\n          }\n        }\n\n        //Set default null value/label if not set\n        if (typeof this.nullValue === 'undefined') {\n          this.nullValue = null;\n        }\n        if (typeof this.nullLabel === 'undefined') {\n          this.nullLabel = 'None';\n        }\n\n        //Set model to null value if not defined or null\n        if (this.isNullable) {\n          if (this.model === null || typeof this.model === 'undefined') {\n            this.model = this.nullValue;\n          }\n        }\n\n        //Validate and mark as dirty if needed\n        if (changes.model) {\n          this.ngModel.$validate();\n          if ($formControls.hasChanged(changes.model)) {\n            this.ngModel.$setDirty();\n          }\n        }\n      };\n\n      /**\n       * Get label value of an option\n       */\n      this.getLabel = function (option) {\n        return getLabelValue(option);\n      };\n\n      /**\n       * Check if given option is selected\n       */\n      this.isSelected = function (option, index) {\n        return isSelected(option, index);\n      };\n\n      /**\n       * Select an option\n       */\n      this.select = function (option, index) {\n\n        //Ignore when disabled\n        if (this.isDisabled) {\n          return;\n        }\n\n        //Get the new model value and call on change handler\n        var value = getModelValue(option, index);\n        this.onChange({ value: value, option: option });\n      };\n    }]\n  });\n})(window, window.angular);\n(function (window, angular, undefined) {\n  'use strict';\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('SelectBox.Component', [])\n\n  /**\n   * Selectbox component\n   */\n  .component('selectBox', {\n    template: '<div class=\"SelectBox {{$ctrl.selectBoxClass}}\">\\n      <div class=\"InputWrapper is-clickable\" ng-click=\"$ctrl.toggleOptions()\">\\n        <div class=\"Caret\"\\n          ng-class=\"{disabled: $ctrl.isDisabled}\"\\n          ng-click=\"$event.stopPropagation(); $ctrl.toggleOptions();\"\\n          ng-if=\"!$ctrl.hasSpinner\"\\n        ></div>\\n        <input readonly class=\"Input {{$ctrl.inputClass}}\" type=\"text\"\\n          ng-value=\"$ctrl.getSelectedLabel()\"\\n          ng-keydown=\"$ctrl.keydown($event)\"\\n          ng-class=\"{disabled: ($ctrl.isDisabled || $ctrl.hasSpinner)}\">\\n        <spinner class=\"Spinner--input\" ng-if=\"$ctrl.hasSpinner\"></spinner>\\n      </div>\\n      <ul class=\"SelectBox-options\" ng-if=\"$ctrl.isShowingOptions\">\\n        <li\\n          ng-if=\"$ctrl.isNullable || !$ctrl.hasOptions()\"\\n          ng-class=\"{selected: $ctrl.isSelection(-1)}\"\\n          ng-mouseover=\"$ctrl.setSelection(-1)\"\\n          ng-click=\"$ctrl.confirmSelection(-1); $event.preventDefault();\"\\n        >{{$ctrl.nullLabel}}</li>\\n        <li\\n          ng-transclude\\n          ng-repeat=\"option in $ctrl.options\"\\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\\n          ng-mouseover=\"$ctrl.setSelection($index)\"\\n          ng-click=\"$ctrl.confirmSelection($index); $event.preventDefault();\"\\n        >{{$ctrl.getLabel(option)}}</li>\\n      </ul>\\n    </div>',\n    transclude: true,\n    require: {\n      ngModel: 'ngModel'\n    },\n    bindings: {\n      model: '<ngModel',\n      options: '<',\n      onChange: '&',\n      isNullable: '<',\n      nullValue: '<',\n      nullLabel: '<',\n      inputClass: '@',\n      filter: '@',\n      isDisabled: '<ngDisabled',\n      hasSpinner: '<hasSpinner'\n    },\n\n    /**\n     * Component controller\n     */\n    controller: ['$element', '$attrs', '$log', '$filter', '$formControls', '$scope', '$document', '$timeout', '$window', function controller($element, $attrs, $log, $filter, $formControls, $scope, $document, $timeout, $window) {\n\n      //Helper vars\n      var $ctrl = this;\n      var selectionIndex = void 0,\n          $input = void 0;\n      var labelBy = $attrs.labelBy || null;\n      var trackBy = $attrs.trackBy || null;\n      var asObject = $attrs.asObject === 'true';\n      var phrase = '';\n\n      //Keycodes\n      var ENTER = 13;\n      var ESC = 27;\n      var UP = 38;\n      var DOWN = 40;\n\n      /**\n       * Debounce helper\n       */\n      function debounce(func, delay) {\n\n        //Timeout placeholder\n        var timeout = void 0;\n\n        //Create wrapper function\n        var wrapper = function wrapper() {\n\n          //Clear any existing timeout\n          if (timeout) {\n            clearTimeout(timeout);\n          }\n\n          //Create new timeout\n          timeout = setTimeout(function () {\n            return func();\n          }, delay);\n        };\n\n        //Return wrapper function\n        return wrapper;\n      }\n\n      /**\n       * Function to clear the phrase (debounced after 1.5 seconds)\n       */\n      var clearPhrase = debounce(function () {\n        phrase = '';\n      }, 1000);\n\n      /**\n       * Check if input was text\n       */\n      function isTextInput(event) {\n        if (event.keyCode >= 48 && event.keyCode <= 57) {\n          return true;\n        }\n        if (event.keyCode >= 65 && event.keyCode <= 90) {\n          return true;\n        }\n        if (event.keyCode === 32) {\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * Click handler for document\n       */\n      function documentClickHandler(event) {\n        if ($ctrl.isShowingOptions && !$element[0].contains(event.target)) {\n          $scope.$apply($ctrl.hideOptions.bind($ctrl));\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      }\n\n      /**\n       * Find scrollable parent\n       */\n      function findScrollableParent($child) {\n\n        //Get parent\n        var $parent = $child.parent();\n        if ($parent.length === 0) {\n          return null;\n        }\n\n        //Get style\n        var style = $window.getComputedStyle($parent[0]);\n\n        //Find element that has auto overflow or which is the body\n        if ($parent[0].tagName === 'BODY' || style.overflowY === 'auto') {\n          return $parent;\n        }\n\n        //Find next\n        return findScrollableParent($parent);\n      }\n\n      /**\n       * Find offset relative to a certain node\n       */\n      function findOffset(node, relativeNode) {\n        var offset = node.offsetTop;\n        while (node.offsetParent && node.offsetParent !== relativeNode) {\n          node = node.offsetParent;\n          offset += node.offsetTop;\n        }\n        return offset;\n      }\n\n      /**\n       * Ensure the whole dropdown is in view\n       */\n      function ensureDropdownInView() {\n\n        //Only if open\n        if (!$ctrl.isShowingOptions) {\n          return;\n        }\n\n        //Find scrollable parent\n        var $parent = findScrollableParent($element);\n        if (!$parent) {\n          return;\n        }\n\n        //Get params\n        var $container = $input.parent().next();\n        var offset = findOffset($container[0], $parent[0]);\n        var height = $parent[0].clientHeight;\n        var scroll = $parent[0].scrollTop;\n        var bottom = offset - scroll + $container[0].clientHeight;\n\n        //Check if it's outside of the height\n        if (bottom > height) {\n          var diff = bottom - height + 16;\n          $parent[0].scrollTop += diff;\n        }\n      }\n\n      /**\n       * Ensure the selected option is in view\n       */\n      function ensureSelectionInView() {\n\n        //Only if open\n        if (!$ctrl.isShowingOptions) {\n          return;\n        }\n\n        //Check index\n        if (!$ctrl.isNullable && selectionIndex < 0) {\n          return;\n        }\n\n        //Find options\n        var $container = $input.parent().next();\n        var $options = $container.children();\n\n        //Get option now, taking into account the additional nullable element\n        var option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n        if (!option) {\n          return;\n        }\n\n        //Determine container and element top and bottom\n        var cTop = $container[0].scrollTop;\n        var cBottom = cTop + $container[0].clientHeight;\n        var eTop = option.offsetTop;\n        var eBottom = eTop + option.clientHeight;\n\n        //Check if out of view\n        if (eTop < cTop) {\n          $container[0].scrollTop -= cTop - eTop;\n        } else if (eBottom > cBottom) {\n          $container[0].scrollTop += eBottom - cBottom;\n        }\n      }\n\n      /**\n       * Move selection up\n       */\n      function moveSelectionUp() {\n        var oldIndex = selectionIndex;\n        if (typeof selectionIndex === 'undefined') {\n          if ($ctrl.isNullable) {\n            selectionIndex = -1;\n          } else if ($ctrl.options.length > 0) {\n            selectionIndex = $ctrl.options.length - 1;\n          }\n        } else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n          selectionIndex--;\n        }\n        if (oldIndex !== selectionIndex) {\n          ensureSelectionInView();\n        }\n      }\n\n      /**\n       * Move selection down\n       */\n      function moveSelectionDown() {\n        var oldIndex = selectionIndex;\n        if (typeof selectionIndex === 'undefined') {\n          if ($ctrl.isNullable) {\n            selectionIndex = -1;\n          } else if ($ctrl.options.length > 0) {\n            selectionIndex = 0;\n          }\n        } else if (selectionIndex < $ctrl.options.length - 1) {\n          selectionIndex++;\n        }\n        if (oldIndex !== selectionIndex) {\n          ensureSelectionInView();\n        }\n      }\n\n      /**\n       * Helper to get the tracking value of an option\n       */\n      function getTrackingValue(option, index) {\n\n        //Null value?\n        if (option === null) {\n          return $ctrl.nullValue;\n        }\n\n        //Tracking by index?\n        if (trackBy === '$index') {\n          return index;\n        }\n\n        //Non object? Track by its value\n        if (!angular.isObject(option)) {\n          return option;\n        }\n\n        //Must have tracking property\n        if (!trackBy) {\n          $log.warn('Missing track-by property for select box');\n          return $ctrl.nullValue;\n        }\n\n        //Validate property\n        if (typeof option[trackBy] === 'undefined') {\n          $log.warn('Unknown property `' + trackBy + '` for select box tracking');\n          return $ctrl.nullValue;\n        }\n\n        //Return the property\n        return option[trackBy];\n      }\n\n      /**\n       * Get the model value\n       */\n      function getModelValue(option, index) {\n\n        //If nullable and null option given, return null value\n        if ($ctrl.isNullable && option === null) {\n          return $ctrl.nullValue;\n        }\n\n        //If returning as object, return the selected option\n        if (asObject) {\n          return option;\n        }\n\n        //Otherwise, return the tracking value of the given option\n        return getTrackingValue(option, index);\n      }\n\n      /**\n       * Get label value of an option\n       */\n      function getLabelValue(option) {\n\n        //Null value?\n        if (option === null || typeof option === 'undefined') {\n          return $ctrl.nullLabel;\n        }\n\n        //Non object? Use its value, filtering if needed\n        if (!angular.isObject(option)) {\n          if ($ctrl.$filter) {\n            return $ctrl.$filter(option);\n          }\n          return option;\n        }\n\n        //Must have label property\n        if (!labelBy) {\n          $log.warn('Missing label-by property for select box');\n          return '';\n        }\n\n        //Validate property\n        if (typeof option[labelBy] === 'undefined') {\n          $log.warn('Unknown property `' + labelBy + '` for select box label');\n          return '';\n        }\n\n        //Return the property, filtering if needed\n        if ($ctrl.$filter) {\n          return $ctrl.$filter(option[labelBy]);\n        }\n        return option[labelBy];\n      }\n\n      /**\n       * Find the selected option based on the model value\n       */\n      function findOption(model, options) {\n\n        //Nothing selected or null value selected?\n        if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n          return null;\n        }\n\n        //Tracking by index?\n        if (trackBy === '$index') {\n          if (typeof options[model] !== 'undefined') {\n            return options[model];\n          }\n          return null;\n        }\n\n        //Get the model value\n        var modelValue = getTrackingValue(model, model);\n\n        //Find matching option\n        return options.find(function (option, index) {\n          var optionValue = getTrackingValue(option, index);\n          return modelValue === optionValue;\n        });\n      }\n\n      /**\n       * Initialization\n       */\n      this.$onInit = function () {\n\n        //Check configuration\n        if (asObject && trackBy === '$index') {\n          $log.warn('Cannot track select box by index if model is an object');\n          asObject = false;\n        }\n\n        //Initialize flags\n        this.isShowingOptions = false;\n\n        //Resolve filter\n        if (this.filter) {\n          this.$filter = $filter(this.filter);\n        }\n\n        //Propagate classes\n        this.selectBoxClass = $element[0].className;\n        $element[0].className = '';\n\n        //Find input\n        $input = $element.find('input');\n\n        //Apply global click handler\n        //NOTE: applied on body, so that it can prevent global $document handlers\n        $document.find('body').on('click', documentClickHandler);\n\n        //Empty check override in order for ng-required to work properly\n        this.ngModel.$isEmpty = function () {\n          if ($ctrl.isNullable) {\n            return $ctrl.model === $ctrl.nullValue;\n          }\n          return $ctrl.model === null || $ctrl.model === $ctrl.nullValue || typeof $ctrl.model === 'undefined';\n        };\n      };\n\n      /**\n       * Destroy\n       */\n      this.$onDestroy = function () {\n        $document.find('body').off('click', documentClickHandler);\n      };\n\n      /**\n       * On change\n       */\n      this.$onChanges = function (changes) {\n\n        //Must have array as options\n        if (!angular.isArray(this.options)) {\n          if (typeof this.options === 'string') {\n            var options = this.options.split('\\n');\n            var set = new Set(options);\n            this.options = Array.from(set.values());\n          } else {\n            this.options = [];\n          }\n        }\n\n        //Set default null value/label if not set\n        if (typeof this.nullValue === 'undefined') {\n          this.nullValue = null;\n        }\n        if (typeof this.nullLabel === 'undefined') {\n          this.nullLabel = '...';\n        }\n\n        //Set model to null value if not defined or null\n        if (this.isNullable) {\n          if (this.model === null || typeof this.model === 'undefined') {\n            this.model = this.nullValue;\n          }\n        }\n\n        //If disabled, hide options\n        if (this.isDisabled) {\n          this.isShowingOptions = false;\n        }\n\n        //Determine selection index\n        var option = findOption(this.model, this.options);\n        selectionIndex = this.options.indexOf(option);\n\n        //Validate and mark as dirty if needed\n        if (changes.model) {\n          this.ngModel.$validate();\n          if ($formControls.hasChanged(changes.model)) {\n            this.ngModel.$setDirty();\n          }\n        }\n      };\n\n      /**\n       * Keydown handler for input element\n       */\n      this.keydown = function (event) {\n\n        //Move selection up or down\n        if (event.keyCode === UP) {\n          event.preventDefault();\n          if (this.isShowingOptions) {\n            moveSelectionUp();\n          } else {\n            this.showOptions();\n          }\n        } else if (event.keyCode === DOWN) {\n          event.preventDefault();\n          if (this.isShowingOptions) {\n            moveSelectionDown();\n          } else {\n            this.showOptions();\n          }\n        }\n\n        //Confirm selection\n        else if (event.keyCode === ENTER && this.isShowingOptions) {\n            event.preventDefault();\n            this.confirmSelection();\n          }\n\n          //Hide options\n          else if (event.keyCode === ESC && this.isShowingOptions) {\n              event.preventDefault();\n              this.hideOptions();\n            }\n\n            //Show options\n            else if (event.keyCode === ENTER && !this.isShowingOptions) {\n                event.preventDefault();\n                this.showOptions();\n              }\n\n              //Text input\n              else if (isTextInput(event)) {\n                  var char = String.fromCharCode(event.keyCode);\n                  this.selectByInput(char);\n                }\n      };\n\n      /**\n       * Get label value of selected option\n       */\n      this.getSelectedLabel = function () {\n        var option = findOption(this.model, this.options);\n        return getLabelValue(option);\n      };\n\n      /**\n       * Get label value of an option\n       */\n      this.getLabel = function (option) {\n        return getLabelValue(option);\n      };\n\n      /**\n       * Show options\n       */\n      this.showOptions = function () {\n        if (!this.isDisabled && !this.hasSpinner) {\n          this.isShowingOptions = true;\n          $timeout(function () {\n            ensureDropdownInView();\n            ensureSelectionInView();\n          });\n        }\n      };\n\n      /**\n       * Hide options\n       */\n      this.hideOptions = function () {\n        this.isShowingOptions = false;\n      };\n\n      /**\n       * Toggle options\n       */\n      this.toggleOptions = function () {\n        if (this.isShowingOptions) {\n          this.hideOptions();\n        } else {\n          this.showOptions();\n        }\n      };\n\n      /**\n       * Has options check\n       */\n      this.hasOptions = function () {\n        return this.options.length > 0;\n      };\n\n      /**\n       * Select by input character(s)\n       */\n      this.selectByInput = function (char) {\n\n        //Lowercase all the things\n        char = char.toLowerCase();\n\n        //Add to phrase\n        phrase += char;\n\n        //Create regex\n        var regex = new RegExp('^' + phrase, 'i');\n\n        //Find matching option\n        var option = this.options.find(function (option) {\n          var label = getLabelValue(option);\n          return String(label).match(regex);\n        });\n\n        //Match found?\n        if (option) {\n          var index = this.options.findIndex(function (o) {\n            return o === option;\n          });\n          this.select(option, index, true);\n        }\n\n        //Clear phrase (debounced)\n        clearPhrase();\n      };\n\n      /**\n       * Select an option\n       */\n      this.select = function (option, index, leaveOpen) {\n\n        //Ignore when disabled\n        if (this.isDisabled) {\n          return;\n        }\n\n        //Hide options\n        if (!leaveOpen) {\n          this.hideOptions();\n        } else {\n          ensureSelectionInView();\n        }\n\n        //Get the new model value and call on change handler\n        var value = getModelValue(option, index);\n        this.onChange({ value: value, option: option });\n      };\n\n      /**\n       * Set the selection index\n       */\n      this.setSelection = function (index) {\n        selectionIndex = index;\n      };\n\n      /**\n       * Check if given index is the selection index\n       */\n      this.isSelection = function (index) {\n        return selectionIndex === index;\n      };\n\n      /**\n       * Confirm selection\n       */\n      this.confirmSelection = function (index) {\n\n        //If index not given, use current selection index\n        if (typeof index === 'undefined') {\n          index = selectionIndex;\n        }\n\n        //Initialize option\n        var option = void 0;\n\n        //Nullable and -1 index given?\n        if (this.isNullable && index === -1) {\n          option = null;\n        }\n\n        //Otherwise, take from given options\n        else {\n\n            //Validate index\n            if (!this.hasOptions() || typeof index === 'undefined' || typeof this.options[index] === 'undefined') {\n              return;\n            }\n\n            //Get option\n            option = this.options[index];\n          }\n\n        //Select option now\n        this.select(option, index);\n      };\n    }]\n  });\n})(window, window.angular);\n(function (window, angular, undefined) {\n  'use strict';\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('TypeAhead.Component', [])\n\n  /**\n   * Type ahead component\n   */\n  .component('typeAhead', {\n    template: '<div class=\"TypeAhead {{$ctrl.typeAheadClass}}\">\\n      <input class=\"Input {{$ctrl.inputClass}}\" type=\"text\"\\n        placeholder=\"{{$ctrl.placeholder}}\"\\n        ng-keydown=\"$ctrl.keydown($event)\"\\n        ng-keyup=\"$ctrl.keyup($event)\"\\n        ng-disabled=\"$ctrl.isDisabled\"\\n        ng-model=\"$ctrl.searchQuery\">\\n      <spinner class=\"Spinner--input\" ng-if=\"$ctrl.isSearching\"></spinner>\\n      <ul class=\"TypeAhead-results\" ng-if=\"$ctrl.isShowingResults\">\\n        <li\\n          ng-repeat=\"item in $ctrl.results\"\\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\\n          ng-mouseover=\"$ctrl.setSelection($index)\"\\n          ng-click=\"$ctrl.confirmSelection($index)\"\\n          ng-transclude>\\n          <span ng-bind-html=\"$ctrl.getLabel(item) |\\n            markmatches:$ctrl.searchQuery:\\'strong\\'\"></span>\\n        </li>\\n      </ul>\\n    </div>',\n    transclude: true,\n    require: {\n      ngModel: 'ngModel'\n    },\n    bindings: {\n      model: '<ngModel',\n      inputClass: '@',\n      options: '<',\n      placeholder: '@',\n      debounce: '<',\n      onSearch: '&',\n      onChange: '&',\n      onQuery: '&',\n      isDisabled: '<ngDisabled',\n      labelBy: '@',\n      trackBy: '@',\n      asObject: '@',\n      minLength: '@',\n      allowNew: '@'\n    },\n\n    /**\n     * Component controller\n     */\n    controller: ['$element', '$scope', '$formControls', '$attrs', '$log', '$q', '$timeout', '$document', function controller($element, $scope, $formControls, $attrs, $log, $q, $timeout, $document) {\n\n      //Helper vars\n      var $input = void 0;\n      var selectionIndex = -1;\n      var $ctrl = this;\n      var labelBy = $attrs.labelBy || null;\n      var trackBy = $attrs.trackBy || null;\n      var asObject = $attrs.asObject === 'true';\n      var allowNew = $attrs.allowNew === 'true';\n\n      //Keep track of searches, prevent older searches overwriting newer ones\n      var currentSearch = 0;\n      var lastProcessedSearch = 0;\n      var pendingSearch = null;\n\n      //Keycodes\n      var ENTER = 13;\n      var ESC = 27;\n      var TAB = 9;\n      var LEFT = 37;\n      var UP = 38;\n      var RIGHT = 39;\n      var DOWN = 40;\n      var SHIFT = 16;\n      var CTRL = 17;\n      var ALT = 18;\n      var CAPSLOCK = 20;\n      var CMDLEFT = 91;\n      var CMDRIGHT = 93;\n\n      /**\n       * Check if input was control\n       */\n      function isControlInput(event) {\n        var keys = [UP, DOWN, LEFT, RIGHT, ENTER, ESC, TAB, SHIFT, CTRL, ALT, CAPSLOCK, CMDLEFT, CMDRIGHT];\n        return keys.indexOf(event.keyCode) > -1;\n      }\n\n      /**\n       * Click handler for document\n       */\n      function documentClickHandler(event) {\n        if (!$input[0].contains(event.target) && $ctrl.isShowingResults) {\n          $scope.$apply($ctrl.hideResults.bind($ctrl));\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      }\n\n      /**\n       * Ensure the selected option is in view\n       */\n      function ensureSelectionInView() {\n\n        //Only if open\n        if (!$ctrl.isShowingResults) {\n          return;\n        }\n\n        //Check index\n        if (!$ctrl.isNullable && selectionIndex < 0) {\n          return;\n        }\n\n        //Find options\n        var $container = $input.next().next();\n        var $options = $container.find('li');\n\n        //Get option now, taking into account the additional nullable element\n        var option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n        if (!option) {\n          return;\n        }\n\n        //Determine container and element top and bottom\n        var cTop = $container[0].scrollTop;\n        var cBottom = cTop + $container[0].clientHeight;\n        var eTop = option.offsetTop;\n        var eBottom = eTop + option.clientHeight;\n\n        //Check if out of view\n        if (eTop < cTop) {\n          $container[0].scrollTop -= cTop - eTop;\n        } else if (eBottom > cBottom) {\n          $container[0].scrollTop += eBottom - cBottom;\n        }\n      }\n\n      /**\n       * Move selection up\n       */\n      function moveSelectionUp() {\n        var oldIndex = selectionIndex;\n        if (typeof selectionIndex === 'undefined') {\n          if ($ctrl.isNullable) {\n            selectionIndex = -1;\n          } else if ($ctrl.results.length > 0) {\n            selectionIndex = $ctrl.results.length - 1;\n          }\n        } else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n          selectionIndex--;\n        }\n        if (oldIndex !== selectionIndex) {\n          ensureSelectionInView();\n        }\n      }\n\n      /**\n       * Move selection down\n       */\n      function moveSelectionDown() {\n        var oldIndex = selectionIndex;\n        if (typeof selectionIndex === 'undefined') {\n          if ($ctrl.isNullable) {\n            selectionIndex = -1;\n          } else if ($ctrl.results.length > 0) {\n            selectionIndex = 0;\n          }\n        } else if (selectionIndex < $ctrl.results.length - 1) {\n          selectionIndex++;\n        }\n        if (oldIndex !== selectionIndex) {\n          ensureSelectionInView();\n        }\n      }\n\n      /**\n       * Helper to get the tracking value of an option\n       */\n      function getTrackingValue(option) {\n\n        //Non object? Track by its value\n        if (option === null || !angular.isObject(option)) {\n          return option;\n        }\n\n        //Must have tracking property\n        if (!trackBy) {\n          $log.warn('Missing track-by property for type ahead');\n          return null;\n        }\n\n        //Validate property\n        if (typeof option[trackBy] === 'undefined') {\n          $log.warn('Unknown property `' + trackBy + '` for type ahead tracking');\n          return null;\n        }\n\n        //Return the property\n        return option[trackBy];\n      }\n\n      /**\n       * Get the model value\n       */\n      function getModelValue(option) {\n\n        //If returning as object, return the selected option\n        if (asObject) {\n          return option;\n        }\n\n        //Otherwise, return the tracking value of the given option\n        return getTrackingValue(option);\n      }\n\n      /**\n       * Get label value of an option\n       */\n      function getLabelValue(option) {\n\n        //Null value?\n        if (option === null || typeof option === 'undefined') {\n          return '';\n        }\n\n        //Non object? Use its value\n        if (!angular.isObject(option)) {\n          return option;\n        }\n\n        //Must have label property\n        if (!labelBy) {\n          $log.warn('Missing label-by property for type ahead');\n          return '';\n        }\n\n        //Validate property\n        if (typeof option[labelBy] === 'undefined') {\n          $log.warn('Unknown property `' + labelBy + '` for type ahead label');\n          return '';\n        }\n\n        //Return the property\n        return option[labelBy];\n      }\n\n      /**\n       * Find the selected option based on the model value\n       */\n      function findOption(model, options) {\n\n        //Nothing selected or null value selected?\n        if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n          return null;\n        }\n\n        //Tracking by index?\n        if (trackBy === '$index') {\n          if (typeof options[model] !== 'undefined') {\n            return options[model];\n          }\n          return null;\n        }\n\n        //Get the model value\n        var modelValue = getTrackingValue(model, model);\n\n        //Find matching option\n        return options.find(function (option, index) {\n          var optionValue = getTrackingValue(option, index);\n          return modelValue === optionValue;\n        });\n      }\n\n      /**\n       * Do a simple search on object property\n       */\n      function searchOptions(value) {\n        if (!value) {\n          return $q.resolve([]);\n        }\n        var regex = new RegExp('(?:^|\\\\b)(' + value + ')', 'i');\n        var items = $ctrl.options.filter(function (option) {\n          var label = getLabelValue(option);\n          return regex.test(label);\n        });\n        return $q.resolve(items);\n      }\n\n      /**\n       * Init\n       */\n      this.$onInit = function () {\n\n        //Find some elements\n        $input = $element.find('input');\n\n        //Propagate focus\n        $element.attr('tabindex', -1);\n        $element.on('focus', function () {\n          $input[0].focus();\n        });\n\n        //Propagate classes\n        this.typeAheadClass = $element[0].className;\n        $element[0].className = '';\n\n        //Apply document click handler\n        //NOTE: applied on body, so that it can prevent global $document handlers\n        $document.find('body').on('click', documentClickHandler);\n\n        //Initialize results and flags\n        this.results = [];\n        this.isSearching = false;\n        this.isShowingResults = false;\n\n        //Empty check override in order for ng-required to work properly\n        this.ngModel.$isEmpty = function () {\n          if ($ctrl.model === null || typeof $ctrl.model === 'undefined') {\n            if (allowNew && $ctrl.searchQuery) {\n              return false;\n            }\n            return true;\n          }\n          return false;\n        };\n      };\n\n      /**\n       * Destroy\n       */\n      this.$onDestroy = function () {\n        $document.find('body').off('click', documentClickHandler);\n      };\n\n      /**\n       * Change handler\n       */\n      this.$onChanges = function (changes) {\n\n        //Validate and mark as dirty if needed\n        if (changes.model) {\n\n          //Only update search query when we have a model\n          //This is to prevent the input from being cleared when we go and edit\n          if (this.model) {\n            var option = void 0;\n            if (angular.isArray(this.options)) {\n              option = findOption(this.model, this.options);\n            } else if (angular.isObject(this.model)) {\n              option = this.model;\n            }\n            if (option) {\n              this.searchQuery = getLabelValue(option);\n            }\n          }\n\n          //Validate model\n          this.ngModel.$validate();\n          if ($formControls.hasChanged(changes.model)) {\n            this.ngModel.$setDirty();\n          }\n        }\n      };\n\n      /**\n       * Get label value of an option\n       */\n      this.getLabel = function (option) {\n        return getLabelValue(option);\n      };\n\n      /**\n       * Key down handler\n       */\n      this.keydown = function (event) {\n\n        //Arrows up/down, move selection\n        if (this.isShowingResults) {\n          if (event.keyCode === UP) {\n            event.preventDefault();\n            moveSelectionUp();\n          } else if (event.keyCode === DOWN) {\n            event.preventDefault();\n            moveSelectionDown();\n          } else if (event.keyCode === ESC) {\n            event.preventDefault();\n            this.hideResults();\n          } else if (event.keyCode === TAB) {\n            //Don't prevent default\n            this.hideResults();\n          } else if (event.keyCode === ENTER) {\n            event.preventDefault();\n            this.confirmSelection();\n          }\n        }\n\n        //Show options\n        else if (event.keyCode === ENTER) {\n            event.preventDefault();\n            this.showResults();\n          }\n      };\n\n      /**\n       * Key up handler\n       */\n      this.keyup = function (event) {\n\n        //If control input, skip further handling\n        if (isControlInput(event)) {\n          return;\n        }\n\n        //Get search query\n        var value = (this.searchQuery || '').trim();\n\n        //Unchanged search query?\n        if (value === this.lastValue) {\n          return;\n        }\n\n        //Set new value\n        this.lastValue = value;\n\n        //Call event handlers\n        this.onQuery({ value: value });\n        this.onChange({ value: null, option: null });\n\n        //Validate and mark as dirty\n        this.ngModel.$validate();\n        this.ngModel.$setDirty();\n\n        //Cancel any old pending search\n        if (pendingSearch) {\n          $timeout.cancel(pendingSearch);\n        }\n\n        //Should we search?\n        if (!this.minLength || value.length >= this.minLength) {\n          this.search(value);\n        } else if (this.hasResults()) {\n          this.clearResults();\n          this.clearSelection();\n        }\n      };\n\n      /**************************************************************************\n       * Search\n       ***/\n\n      /**\n       * Search wrapper\n       */\n      this.search = function (value) {\n        var _this = this;\n\n        //Create new debounced search\n        pendingSearch = $timeout(function () {\n          pendingSearch = null;\n          return _this.doSearch(value);\n        }, this.debounce || 250);\n\n        //Return the promise\n        return pendingSearch;\n      };\n\n      /**\n       * Actual search handler\n       */\n      this.doSearch = function (value) {\n        var _this2 = this;\n\n        //Determine search handler\n        var search = void 0;\n        if (this.options && angular.isArray(this.options)) {\n          search = searchOptions(value);\n        } else if ($attrs.onSearch) {\n          search = this.onSearch({ value: value });\n        } else {\n          $log.warn('No search handler or options specified');\n          return $q.reject();\n        }\n\n        //Toggle flag\n        this.isSearching = true;\n\n        //Return search promise\n        return search\n\n        //Check if we've gotten an old search back\n        .then(function (results) {\n          if (++currentSearch > lastProcessedSearch) {\n            return results;\n          }\n          return $q.reject('old search');\n        })\n\n        //Process the results\n        .then(function (results) {\n          _this2.clearSelection();\n          _this2.results = results;\n          if (results && results.length > 0) {\n            _this2.isShowingResults = true;\n          }\n          lastProcessedSearch = currentSearch;\n        })\n\n        //Done searching\n        .finally(function () {\n          return _this2.isSearching = false;\n        });\n      };\n\n      /**************************************************************************\n       * Results navigation & handling\n       ***/\n\n      /**\n       * Check if we have results\n       */\n      this.hasResults = function () {\n        return this.results && this.results.length > 0;\n      };\n\n      /**\n       * Clear results\n       */\n      this.clearResults = function () {\n        this.results = [];\n        this.isShowingResults = false;\n      };\n\n      /**\n       * Show results\n       */\n      this.showResults = function () {\n        if (this.hasResults()) {\n          this.isShowingResults = true;\n        }\n      };\n\n      /**\n       * Select an option\n       */\n      this.select = function (option) {\n\n        //Ignore when disabled\n        if (this.isDisabled) {\n          return;\n        }\n\n        //Hide options\n        this.hideResults();\n\n        //Get the new model and label values\n        var value = getModelValue(option);\n        var label = getLabelValue(option);\n\n        //Set as search query\n        this.searchQuery = label;\n\n        //Call event handlers\n        this.onQuery({ value: label });\n        this.onChange({ value: value, option: option });\n      };\n\n      /**\n       * Hide results\n       */\n      this.hideResults = function () {\n        this.isShowingResults = false;\n      };\n\n      /**\n       * Set the selection index\n       */\n      this.setSelection = function (index) {\n        selectionIndex = index;\n      };\n\n      /**\n       * Check if given index is the selection index\n       */\n      this.isSelection = function (index) {\n        return selectionIndex === index;\n      };\n\n      /**\n       * Clear selection\n       */\n      this.clearSelection = function () {\n        selectionIndex = undefined;\n      };\n\n      /**\n       * Confirm selection\n       */\n      this.confirmSelection = function (index) {\n\n        //If index not given, use current selection index\n        if (typeof index === 'undefined') {\n          index = selectionIndex;\n        }\n\n        //Validate index\n        if (this.results.length === 0 || typeof this.results[index] === 'undefined') {\n          return;\n        }\n\n        //Select result\n        this.select(this.results[index]);\n      };\n    }]\n  });\n})(window, window.angular);","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('CheckBox.Component', [])\n\n/**\n * Checkbox component\n */\n.component('checkBox', {\n  template:\n    `<label class=\"CheckBox {{$ctrl.classes}}\"\n      ng-transclude\n      ng-click=\"$ctrl.toggle($event)\"\n      ng-class=\"{checked: $ctrl.isChecked(), disabled: $ctrl.isDisabled}\"\n    ></label>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  transclude: true,\n  bindings: {\n    model: '<ngModel',\n    onChange: '&',\n    isInverse: '<isInverse',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $formControls) {\n\n    //Get instance\n    let $ctrl = this;\n\n    /**\n     * On init\n     */\n    this.$onInit = function() {\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Add checkbox wrapper class to parent component\n      $element.addClass('CheckBoxWrapper');\n\n      //Find label\n      const $label = $element.find('label');\n\n      //Propagate focus\n      $element.on('focus', () => {\n        $label[0].focus();\n      });\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isInverse) {\n          return !!$ctrl.model;\n        }\n        return !$ctrl.model;\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Toggle\n     */\n    this.toggle = function(event) {\n\n      //Don't toggle when disabled or event default prevented\n      if (this.isDisabled || event.defaultPrevented) {\n        return;\n      }\n\n      //Get boolean value and call on change handler\n      let value = !this.model;\n      this.onChange({value});\n    };\n\n    /**\n     * Check if checked\n     */\n    this.isChecked = function() {\n      return (this.isInverse ? !this.model : !!this.model);\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('CheckBoxes.Component', [])\n\n/**\n * Checkboxes component\n */\n.component('checkBoxes', {\n  template:\n    `<div class=\"CheckBoxGroup {{$ctrl.classes}}\">\n      <label class=\"CheckBox\"\n        ng-repeat=\"option in $ctrl.options\"\n        ng-click=\"$ctrl.toggle(option, $index)\"\n        ng-class=\"{checked: $ctrl.isChecked(option, $index), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.getLabel(option)}}</label>\n    </div>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    min: '<',\n    max: '<',\n    onChange: '&',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $attrs, $log, $formControls) {\n\n    //Helper vars\n    let $ctrl = this;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for check boxes');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for check box tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for check boxes');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for check box label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Check if a certain option is checked\n     */\n    function isChecked(model, option, index) {\n\n      //Nothing selected?\n      if (!angular.isArray(model) || model.length === 0) {\n        return false;\n      }\n\n      //Get option value\n      let optionValue = getTrackingValue(option, index);\n\n      //See if present in model values\n      let find = model.find(model => {\n        let modelValue = getTrackingValue(model, model);\n        return (modelValue === optionValue);\n      });\n      return (typeof find !== 'undefined');\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track check boxes by index if model is an object');\n        asObject = false;\n      }\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Validation for min/max values\n      this.ngModel.$validators.min = function(modelValue) {\n        if ($ctrl.ngModel.$error.required) {\n          return true;\n        }\n        if (!$ctrl.min || $ctrl.min < 0) {\n          return true;\n        }\n        return (!angular.isArray(modelValue) || modelValue.length >= $ctrl.min);\n      };\n      this.ngModel.$validators.max = function(modelValue) {\n        if ($ctrl.ngModel.$error.required) {\n          return true;\n        }\n        if (!$ctrl.max || $ctrl.max < 0) {\n          return true;\n        }\n        return (!angular.isArray(modelValue) || modelValue.length <= $ctrl.max);\n      };\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n\n        //Needed here to prevent $validate from setting the model to undefined\n        //NOTE: first approach for Angular < 1.6.0\n        if (typeof $ctrl.ngModel.$$setOptions === 'function') {\n          $ctrl.ngModel.$$setOptions({\n            allowInvalid: true,\n          });\n        }\n        else {\n          $ctrl.ngModel.$options = $ctrl.ngModel.$options.createChild({\n            allowInvalid: true,\n          });\n        }\n\n        //Return check now\n        return (!angular.isArray($ctrl.model) || $ctrl.model.length === 0);\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          const options = this.options.split('\\n');\n          const set = new Set(options);\n          this.options = Array.from(set.values());\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Check if given option is checked\n     */\n    this.isChecked = function(option, index) {\n      return isChecked(this.model, option, index);\n    };\n\n    /**\n     * Toggle an option\n     */\n    this.toggle = function(option, index) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Initialize value of our model array\n      let value = [];\n      if (angular.isArray(this.model)) {\n        value = this.model.map(item => item);\n      }\n\n      //Check if currently checked (use source model) and get the item value\n      let checked = isChecked(value, option, index);\n      let optionValue = getTrackingValue(option, index);\n\n      //If checked, remove from target model, otherwise add\n      if (checked) {\n        let i = value.findIndex(model => {\n          let modelValue = getTrackingValue(model, model);\n          return (modelValue === optionValue);\n        });\n        value.splice(i, 1);\n      }\n      else {\n        value.push(asObject ? option : optionValue);\n      }\n\n      //Call on change handler\n      this.onChange({value});\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('FormControls.Component', [\n  'CheckBox.Component',\n  'CheckBoxes.Component',\n  'RadioButtons.Component',\n  'SelectBox.Component',\n  'TypeAhead.Component',\n])\n\n/**\n * Helper service\n */\n.factory('$formControls', function() {\n  return {\n\n    /**\n     * Check if an item value really changed (deep checking with angular.equals)\n     */\n    hasChanged(changes) {\n\n      //Get previous and current value\n      let {previousValue, currentValue} = changes;\n\n      //If unitialized, don't trigger changes\n      if (previousValue === 'UNINITIALIZED_VALUE') {\n        return false;\n      }\n\n      //Check if equals\n      return !angular.equals(previousValue, currentValue);\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('RadioButtons.Component', [])\n\n/**\n * Radio buttons component\n */\n.component('radioButtons', {\n  template:\n    `<div class=\"RadioButtonGroup {{$ctrl.classes}}\">\n      <label class=\"RadioButton\"\n        ng-if=\"$ctrl.isNullable\"\n        ng-click=\"$ctrl.select(null)\"\n        ng-class=\"{checked: $ctrl.isSelected(null), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.nullLabel}}</label>\n      <label class=\"RadioButton\"\n        ng-repeat=\"option in $ctrl.options\"\n        ng-click=\"$ctrl.select(option, $index)\"\n        ng-class=\"{checked: $ctrl.isSelected(option, $index), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.getLabel(option)}}</label>\n    </div>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    onChange: '&',\n    isNullable: '<',\n    nullValue: '<',\n    nullLabel: '<',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $attrs, $log, $formControls) {\n\n    //Helper vars\n    let $ctrl = this;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for radio buttons');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for radio tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option, index) {\n\n      //If nullable and null option given, return null value\n      if ($ctrl.isNullable && option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option, index);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullLabel;\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for selectbox');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for selectbox label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Check if a certain option is selected\n     */\n    function isSelected(option, index) {\n\n      //Nullable and null value selected?\n      if (\n        $ctrl.isNullable &&\n        $ctrl.model === $ctrl.nullValue &&\n        option === null) {\n        return true;\n      }\n\n      //Nothing selected?\n      if ($ctrl.model === null) {\n        return false;\n      }\n\n      //Get the model and option values\n      let modelValue = getTrackingValue($ctrl.model, $ctrl.model);\n      let optionValue = getTrackingValue(option, index);\n\n      //Compare the two\n      return (modelValue === optionValue);\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track radio buttons by index if model is an object');\n        asObject = false;\n      }\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isNullable) {\n          return ($ctrl.model === $ctrl.nullValue);\n        }\n        return (\n          $ctrl.model === null ||\n          $ctrl.model === $ctrl.nullValue ||\n          typeof $ctrl.model === 'undefined'\n        );\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          const options = this.options.split('\\n');\n          const set = new Set(options);\n          this.options = Array.from(set.values());\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Set default null value/label if not set\n      if (typeof this.nullValue === 'undefined') {\n        this.nullValue = null;\n      }\n      if (typeof this.nullLabel === 'undefined') {\n        this.nullLabel = 'None';\n      }\n\n      //Set model to null value if not defined or null\n      if (this.isNullable) {\n        if (this.model === null || typeof this.model === 'undefined') {\n          this.model = this.nullValue;\n        }\n      }\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Check if given option is selected\n     */\n    this.isSelected = function(option, index) {\n      return isSelected(option, index);\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option, index) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Get the new model value and call on change handler\n      let value = getModelValue(option, index);\n      this.onChange({value, option});\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('SelectBox.Component', [])\n\n/**\n * Selectbox component\n */\n.component('selectBox', {\n  template:\n    `<div class=\"SelectBox {{$ctrl.selectBoxClass}}\">\n      <div class=\"InputWrapper is-clickable\" ng-click=\"$ctrl.toggleOptions()\">\n        <div class=\"Caret\"\n          ng-class=\"{disabled: $ctrl.isDisabled}\"\n          ng-click=\"$event.stopPropagation(); $ctrl.toggleOptions();\"\n          ng-if=\"!$ctrl.hasSpinner\"\n        ></div>\n        <input readonly class=\"Input {{$ctrl.inputClass}}\" type=\"text\"\n          ng-value=\"$ctrl.getSelectedLabel()\"\n          ng-keydown=\"$ctrl.keydown($event)\"\n          ng-class=\"{disabled: ($ctrl.isDisabled || $ctrl.hasSpinner)}\">\n        <spinner class=\"Spinner--input\" ng-if=\"$ctrl.hasSpinner\"></spinner>\n      </div>\n      <ul class=\"SelectBox-options\" ng-if=\"$ctrl.isShowingOptions\">\n        <li\n          ng-if=\"$ctrl.isNullable || !$ctrl.hasOptions()\"\n          ng-class=\"{selected: $ctrl.isSelection(-1)}\"\n          ng-mouseover=\"$ctrl.setSelection(-1)\"\n          ng-click=\"$ctrl.confirmSelection(-1); $event.preventDefault();\"\n        >{{$ctrl.nullLabel}}</li>\n        <li\n          ng-transclude\n          ng-repeat=\"option in $ctrl.options\"\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\n          ng-mouseover=\"$ctrl.setSelection($index)\"\n          ng-click=\"$ctrl.confirmSelection($index); $event.preventDefault();\"\n        >{{$ctrl.getLabel(option)}}</li>\n      </ul>\n    </div>`,\n  transclude: true,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    onChange: '&',\n    isNullable: '<',\n    nullValue: '<',\n    nullLabel: '<',\n    inputClass: '@',\n    filter: '@',\n    isDisabled: '<ngDisabled',\n    hasSpinner: '<hasSpinner',\n  },\n\n  /**\n   * Component controller\n   */\n  controller(\n    $element, $attrs, $log, $filter, $formControls, $scope,\n    $document, $timeout, $window\n  ) {\n\n    //Helper vars\n    const $ctrl = this;\n    let selectionIndex, $input;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n    let phrase = '';\n\n    //Keycodes\n    const ENTER = 13;\n    const ESC = 27;\n    const UP = 38;\n    const DOWN = 40;\n\n    /**\n     * Debounce helper\n     */\n    function debounce(func, delay) {\n\n      //Timeout placeholder\n      let timeout;\n\n      //Create wrapper function\n      const wrapper = function() {\n\n        //Clear any existing timeout\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n\n        //Create new timeout\n        timeout = setTimeout(() => func(), delay);\n      };\n\n      //Return wrapper function\n      return wrapper;\n    }\n\n    /**\n     * Function to clear the phrase (debounced after 1.5 seconds)\n     */\n    const clearPhrase = debounce(() => {\n      phrase = '';\n    }, 1000);\n\n    /**\n     * Check if input was text\n     */\n    function isTextInput(event) {\n      if (event.keyCode >= 48 && event.keyCode <= 57) {\n        return true;\n      }\n      if (event.keyCode >= 65 && event.keyCode <= 90) {\n        return true;\n      }\n      if (event.keyCode === 32) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Click handler for document\n     */\n    function documentClickHandler(event) {\n      if ($ctrl.isShowingOptions && !$element[0].contains(event.target)) {\n        $scope.$apply($ctrl.hideOptions.bind($ctrl));\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    /**\n     * Find scrollable parent\n     */\n    function findScrollableParent($child) {\n\n      //Get parent\n      const $parent = $child.parent();\n      if ($parent.length === 0) {\n        return null;\n      }\n\n      //Get style\n      const style = $window.getComputedStyle($parent[0]);\n\n      //Find element that has auto overflow or which is the body\n      if ($parent[0].tagName === 'BODY' || style.overflowY === 'auto') {\n        return $parent;\n      }\n\n      //Find next\n      return findScrollableParent($parent);\n    }\n\n    /**\n     * Find offset relative to a certain node\n     */\n    function findOffset(node, relativeNode) {\n      let offset = node.offsetTop;\n      while (node.offsetParent && node.offsetParent !== relativeNode) {\n        node = node.offsetParent;\n        offset += node.offsetTop;\n      }\n      return offset;\n    }\n\n    /**\n     * Ensure the whole dropdown is in view\n     */\n    function ensureDropdownInView() {\n\n      //Only if open\n      if (!$ctrl.isShowingOptions) {\n        return;\n      }\n\n      //Find scrollable parent\n      const $parent = findScrollableParent($element);\n      if (!$parent) {\n        return;\n      }\n\n      //Get params\n      const $container = $input.parent().next();\n      const offset = findOffset($container[0], $parent[0]);\n      const height = $parent[0].clientHeight;\n      const scroll = $parent[0].scrollTop;\n      const bottom = offset - scroll + $container[0].clientHeight;\n\n      //Check if it's outside of the height\n      if (bottom > height) {\n        const diff = bottom - height + 16;\n        $parent[0].scrollTop += diff;\n      }\n    }\n\n    /**\n     * Ensure the selected option is in view\n     */\n    function ensureSelectionInView() {\n\n      //Only if open\n      if (!$ctrl.isShowingOptions) {\n        return;\n      }\n\n      //Check index\n      if (!$ctrl.isNullable && selectionIndex < 0) {\n        return;\n      }\n\n      //Find options\n      const $container = $input.parent().next();\n      const $options = $container.children();\n\n      //Get option now, taking into account the additional nullable element\n      const option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n      if (!option) {\n        return;\n      }\n\n      //Determine container and element top and bottom\n      const cTop = $container[0].scrollTop;\n      const cBottom = cTop + $container[0].clientHeight;\n      const eTop = option.offsetTop;\n      const eBottom = eTop + option.clientHeight;\n\n      //Check if out of view\n      if (eTop < cTop) {\n        $container[0].scrollTop -= (cTop - eTop);\n      }\n      else if (eBottom > cBottom) {\n        $container[0].scrollTop += (eBottom - cBottom);\n      }\n    }\n\n    /**\n     * Move selection up\n     */\n    function moveSelectionUp() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = $ctrl.options.length - 1;\n        }\n      }\n      else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n        selectionIndex--;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Move selection down\n     */\n    function moveSelectionDown() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = 0;\n        }\n      }\n      else if (selectionIndex < ($ctrl.options.length - 1)) {\n        selectionIndex++;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for select box');\n        return $ctrl.nullValue;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for select box tracking');\n        return $ctrl.nullValue;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option, index) {\n\n      //If nullable and null option given, return null value\n      if ($ctrl.isNullable && option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option, index);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null || typeof option === 'undefined') {\n        return $ctrl.nullLabel;\n      }\n\n      //Non object? Use its value, filtering if needed\n      if (!angular.isObject(option)) {\n        if ($ctrl.$filter) {\n          return $ctrl.$filter(option);\n        }\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for select box');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for select box label');\n        return '';\n      }\n\n      //Return the property, filtering if needed\n      if ($ctrl.$filter) {\n        return $ctrl.$filter(option[labelBy]);\n      }\n      return option[labelBy];\n    }\n\n    /**\n     * Find the selected option based on the model value\n     */\n    function findOption(model, options) {\n\n      //Nothing selected or null value selected?\n      if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n        return null;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        if (typeof options[model] !== 'undefined') {\n          return options[model];\n        }\n        return null;\n      }\n\n      //Get the model value\n      let modelValue = getTrackingValue(model, model);\n\n      //Find matching option\n      return options\n        .find((option, index) => {\n          let optionValue = getTrackingValue(option, index);\n          return (modelValue === optionValue);\n        });\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track select box by index if model is an object');\n        asObject = false;\n      }\n\n      //Initialize flags\n      this.isShowingOptions = false;\n\n      //Resolve filter\n      if (this.filter) {\n        this.$filter = $filter(this.filter);\n      }\n\n      //Propagate classes\n      this.selectBoxClass = $element[0].className;\n      $element[0].className = '';\n\n      //Find input\n      $input = $element.find('input');\n\n      //Apply global click handler\n      //NOTE: applied on body, so that it can prevent global $document handlers\n      $document.find('body').on('click', documentClickHandler);\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isNullable) {\n          return ($ctrl.model === $ctrl.nullValue);\n        }\n        return (\n          $ctrl.model === null ||\n          $ctrl.model === $ctrl.nullValue ||\n          typeof $ctrl.model === 'undefined'\n        );\n      };\n    };\n\n    /**\n     * Destroy\n     */\n    this.$onDestroy = function() {\n      $document.find('body').off('click', documentClickHandler);\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          const options = this.options.split('\\n');\n          const set = new Set(options);\n          this.options = Array.from(set.values());\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Set default null value/label if not set\n      if (typeof this.nullValue === 'undefined') {\n        this.nullValue = null;\n      }\n      if (typeof this.nullLabel === 'undefined') {\n        this.nullLabel = '...';\n      }\n\n      //Set model to null value if not defined or null\n      if (this.isNullable) {\n        if (this.model === null || typeof this.model === 'undefined') {\n          this.model = this.nullValue;\n        }\n      }\n\n      //If disabled, hide options\n      if (this.isDisabled) {\n        this.isShowingOptions = false;\n      }\n\n      //Determine selection index\n      let option = findOption(this.model, this.options);\n      selectionIndex = this.options.indexOf(option);\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Keydown handler for input element\n     */\n    this.keydown = function(event) {\n\n      //Move selection up or down\n      if (event.keyCode === UP) {\n        event.preventDefault();\n        if (this.isShowingOptions) {\n          moveSelectionUp();\n        }\n        else {\n          this.showOptions();\n        }\n      }\n      else if (event.keyCode === DOWN) {\n        event.preventDefault();\n        if (this.isShowingOptions) {\n          moveSelectionDown();\n        }\n        else {\n          this.showOptions();\n        }\n      }\n\n      //Confirm selection\n      else if (event.keyCode === ENTER && this.isShowingOptions) {\n        event.preventDefault();\n        this.confirmSelection();\n      }\n\n      //Hide options\n      else if (event.keyCode === ESC && this.isShowingOptions) {\n        event.preventDefault();\n        this.hideOptions();\n      }\n\n      //Show options\n      else if (event.keyCode === ENTER && !this.isShowingOptions) {\n        event.preventDefault();\n        this.showOptions();\n      }\n\n      //Text input\n      else if (isTextInput(event)) {\n        const char = String.fromCharCode(event.keyCode);\n        this.selectByInput(char);\n      }\n    };\n\n    /**\n     * Get label value of selected option\n     */\n    this.getSelectedLabel = function() {\n      let option = findOption(this.model, this.options);\n      return getLabelValue(option);\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Show options\n     */\n    this.showOptions = function() {\n      if (!this.isDisabled && !this.hasSpinner) {\n        this.isShowingOptions = true;\n        $timeout(() => {\n          ensureDropdownInView();\n          ensureSelectionInView();\n        });\n      }\n    };\n\n    /**\n     * Hide options\n     */\n    this.hideOptions = function() {\n      this.isShowingOptions = false;\n    };\n\n    /**\n     * Toggle options\n     */\n    this.toggleOptions = function() {\n      if (this.isShowingOptions) {\n        this.hideOptions();\n      }\n      else {\n        this.showOptions();\n      }\n    };\n\n    /**\n     * Has options check\n     */\n    this.hasOptions = function() {\n      return (this.options.length > 0);\n    };\n\n    /**\n     * Select by input character(s)\n     */\n    this.selectByInput = function(char) {\n\n      //Lowercase all the things\n      char = char.toLowerCase();\n\n      //Add to phrase\n      phrase += char;\n\n      //Create regex\n      const regex = new RegExp('^' + phrase, 'i');\n\n      //Find matching option\n      const option = this.options.find(option => {\n        const label = getLabelValue(option);\n        return String(label).match(regex);\n      });\n\n      //Match found?\n      if (option) {\n        const index = this.options.findIndex(o => o === option);\n        this.select(option, index, true);\n      }\n\n      //Clear phrase (debounced)\n      clearPhrase();\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option, index, leaveOpen) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Hide options\n      if (!leaveOpen) {\n        this.hideOptions();\n      }\n      else {\n        ensureSelectionInView();\n      }\n\n      //Get the new model value and call on change handler\n      let value = getModelValue(option, index);\n      this.onChange({value, option});\n    };\n\n    /**\n     * Set the selection index\n     */\n    this.setSelection = function(index) {\n      selectionIndex = index;\n    };\n\n    /**\n     * Check if given index is the selection index\n     */\n    this.isSelection = function(index) {\n      return (selectionIndex === index);\n    };\n\n    /**\n     * Confirm selection\n     */\n    this.confirmSelection = function(index) {\n\n      //If index not given, use current selection index\n      if (typeof index === 'undefined') {\n        index = selectionIndex;\n      }\n\n      //Initialize option\n      let option;\n\n      //Nullable and -1 index given?\n      if (this.isNullable && index === -1) {\n        option = null;\n      }\n\n      //Otherwise, take from given options\n      else {\n\n        //Validate index\n        if (\n          !this.hasOptions() ||\n          typeof index === 'undefined' ||\n          typeof this.options[index] === 'undefined'\n        ) {\n          return;\n        }\n\n        //Get option\n        option = this.options[index];\n      }\n\n      //Select option now\n      this.select(option, index);\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('TypeAhead.Component', [])\n\n/**\n * Type ahead component\n */\n.component('typeAhead', {\n  template:\n    `<div class=\"TypeAhead {{$ctrl.typeAheadClass}}\">\n      <input class=\"Input {{$ctrl.inputClass}}\" type=\"text\"\n        placeholder=\"{{$ctrl.placeholder}}\"\n        ng-keydown=\"$ctrl.keydown($event)\"\n        ng-keyup=\"$ctrl.keyup($event)\"\n        ng-disabled=\"$ctrl.isDisabled\"\n        ng-model=\"$ctrl.searchQuery\">\n      <spinner class=\"Spinner--input\" ng-if=\"$ctrl.isSearching\"></spinner>\n      <ul class=\"TypeAhead-results\" ng-if=\"$ctrl.isShowingResults\">\n        <li\n          ng-repeat=\"item in $ctrl.results\"\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\n          ng-mouseover=\"$ctrl.setSelection($index)\"\n          ng-click=\"$ctrl.confirmSelection($index)\"\n          ng-transclude>\n          <span ng-bind-html=\"$ctrl.getLabel(item) |\n            markmatches:$ctrl.searchQuery:'strong'\"></span>\n        </li>\n      </ul>\n    </div>`,\n  transclude: true,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    inputClass: '@',\n    options: '<',\n    placeholder: '@',\n    debounce: '<',\n    onSearch: '&',\n    onChange: '&',\n    onQuery: '&',\n    isDisabled: '<ngDisabled',\n    labelBy: '@',\n    trackBy: '@',\n    asObject: '@',\n    minLength: '@',\n    allowNew: '@',\n  },\n\n  /**\n   * Component controller\n   */\n  controller(\n    $element, $scope, $formControls, $attrs, $log, $q, $timeout, $document\n  ) {\n\n    //Helper vars\n    let $input;\n    let selectionIndex = -1;\n    const $ctrl = this;\n    const labelBy = $attrs.labelBy || null;\n    const trackBy = $attrs.trackBy || null;\n    const asObject = ($attrs.asObject === 'true');\n    const allowNew = ($attrs.allowNew === 'true');\n\n    //Keep track of searches, prevent older searches overwriting newer ones\n    let currentSearch = 0;\n    let lastProcessedSearch = 0;\n    let pendingSearch = null;\n\n    //Keycodes\n    const ENTER = 13;\n    const ESC = 27;\n    const TAB = 9;\n    const LEFT = 37;\n    const UP = 38;\n    const RIGHT = 39;\n    const DOWN = 40;\n    const SHIFT = 16;\n    const CTRL = 17;\n    const ALT = 18;\n    const CAPSLOCK = 20;\n    const CMDLEFT = 91;\n    const CMDRIGHT = 93;\n\n    /**\n     * Check if input was control\n     */\n    function isControlInput(event) {\n      const keys = [\n        UP, DOWN, LEFT, RIGHT, ENTER, ESC, TAB, SHIFT,\n        CTRL, ALT, CAPSLOCK, CMDLEFT, CMDRIGHT,\n      ];\n      return (keys.indexOf(event.keyCode) > -1);\n    }\n\n    /**\n     * Click handler for document\n     */\n    function documentClickHandler(event) {\n      if (!$input[0].contains(event.target) && $ctrl.isShowingResults) {\n        $scope.$apply($ctrl.hideResults.bind($ctrl));\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    /**\n     * Ensure the selected option is in view\n     */\n    function ensureSelectionInView() {\n\n      //Only if open\n      if (!$ctrl.isShowingResults) {\n        return;\n      }\n\n      //Check index\n      if (!$ctrl.isNullable && selectionIndex < 0) {\n        return;\n      }\n\n      //Find options\n      const $container = $input.next().next();\n      const $options = $container.find('li');\n\n      //Get option now, taking into account the additional nullable element\n      const option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n      if (!option) {\n        return;\n      }\n\n      //Determine container and element top and bottom\n      const cTop = $container[0].scrollTop;\n      const cBottom = cTop + $container[0].clientHeight;\n      const eTop = option.offsetTop;\n      const eBottom = eTop + option.clientHeight;\n\n      //Check if out of view\n      if (eTop < cTop) {\n        $container[0].scrollTop -= (cTop - eTop);\n      }\n      else if (eBottom > cBottom) {\n        $container[0].scrollTop += (eBottom - cBottom);\n      }\n    }\n\n    /**\n     * Move selection up\n     */\n    function moveSelectionUp() {\n      const oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.results.length > 0) {\n          selectionIndex = $ctrl.results.length - 1;\n        }\n      }\n      else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n        selectionIndex--;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Move selection down\n     */\n    function moveSelectionDown() {\n      const oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.results.length > 0) {\n          selectionIndex = 0;\n        }\n      }\n      else if (selectionIndex < ($ctrl.results.length - 1)) {\n        selectionIndex++;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option) {\n\n      //Non object? Track by its value\n      if (option === null || !angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for type ahead');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for type ahead tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option) {\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null || typeof option === 'undefined') {\n        return '';\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for type ahead');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for type ahead label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Find the selected option based on the model value\n     */\n    function findOption(model, options) {\n\n      //Nothing selected or null value selected?\n      if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n        return null;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        if (typeof options[model] !== 'undefined') {\n          return options[model];\n        }\n        return null;\n      }\n\n      //Get the model value\n      const modelValue = getTrackingValue(model, model);\n\n      //Find matching option\n      return options\n        .find((option, index) => {\n          const optionValue = getTrackingValue(option, index);\n          return (modelValue === optionValue);\n        });\n    }\n\n    /**\n     * Do a simple search on object property\n     */\n    function searchOptions(value) {\n      if (!value) {\n        return $q.resolve([]);\n      }\n      const regex = new RegExp('(?:^|\\\\b)(' + value + ')', 'i');\n      const items = $ctrl.options\n        .filter(option => {\n          const label = getLabelValue(option);\n          return regex.test(label);\n        });\n      return $q.resolve(items);\n    }\n\n    /**\n     * Init\n     */\n    this.$onInit = function() {\n\n      //Find some elements\n      $input = $element.find('input');\n\n      //Propagate focus\n      $element.attr('tabindex', -1);\n      $element.on('focus', () => {\n        $input[0].focus();\n      });\n\n      //Propagate classes\n      this.typeAheadClass = $element[0].className;\n      $element[0].className = '';\n\n      //Apply document click handler\n      //NOTE: applied on body, so that it can prevent global $document handlers\n      $document.find('body').on('click', documentClickHandler);\n\n      //Initialize results and flags\n      this.results = [];\n      this.isSearching = false;\n      this.isShowingResults = false;\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.model === null || typeof $ctrl.model === 'undefined') {\n          if (allowNew && $ctrl.searchQuery) {\n            return false;\n          }\n          return true;\n        }\n        return false;\n      };\n    };\n\n    /**\n     * Destroy\n     */\n    this.$onDestroy = function() {\n      $document.find('body').off('click', documentClickHandler);\n    };\n\n    /**\n     * Change handler\n     */\n    this.$onChanges = function(changes) {\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n\n        //Only update search query when we have a model\n        //This is to prevent the input from being cleared when we go and edit\n        if (this.model) {\n          let option;\n          if (angular.isArray(this.options)) {\n            option = findOption(this.model, this.options);\n          }\n          else if (angular.isObject(this.model)) {\n            option = this.model;\n          }\n          if (option) {\n            this.searchQuery = getLabelValue(option);\n          }\n        }\n\n        //Validate model\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Key down handler\n     */\n    this.keydown = function(event) {\n\n      //Arrows up/down, move selection\n      if (this.isShowingResults) {\n        if (event.keyCode === UP) {\n          event.preventDefault();\n          moveSelectionUp();\n        }\n        else if (event.keyCode === DOWN) {\n          event.preventDefault();\n          moveSelectionDown();\n        }\n        else if (event.keyCode === ESC) {\n          event.preventDefault();\n          this.hideResults();\n        }\n        else if (event.keyCode === TAB) {\n          //Don't prevent default\n          this.hideResults();\n        }\n        else if (event.keyCode === ENTER) {\n          event.preventDefault();\n          this.confirmSelection();\n        }\n      }\n\n      //Show options\n      else if (event.keyCode === ENTER) {\n        event.preventDefault();\n        this.showResults();\n      }\n    };\n\n    /**\n     * Key up handler\n     */\n    this.keyup = function(event) {\n\n      //If control input, skip further handling\n      if (isControlInput(event)) {\n        return;\n      }\n\n      //Get search query\n      const value = (this.searchQuery || '').trim();\n\n      //Unchanged search query?\n      if (value === this.lastValue) {\n        return;\n      }\n\n      //Set new value\n      this.lastValue = value;\n\n      //Call event handlers\n      this.onQuery({value});\n      this.onChange({value: null, option: null});\n\n      //Validate and mark as dirty\n      this.ngModel.$validate();\n      this.ngModel.$setDirty();\n\n      //Cancel any old pending search\n      if (pendingSearch) {\n        $timeout.cancel(pendingSearch);\n      }\n\n      //Should we search?\n      if (!this.minLength || value.length >= this.minLength) {\n        this.search(value);\n      }\n      else if (this.hasResults()) {\n        this.clearResults();\n        this.clearSelection();\n      }\n    };\n\n    /**************************************************************************\n     * Search\n     ***/\n\n    /**\n     * Search wrapper\n     */\n    this.search = function(value) {\n\n      //Create new debounced search\n      pendingSearch = $timeout(() => {\n        pendingSearch = null;\n        return this.doSearch(value);\n      }, this.debounce || 250);\n\n      //Return the promise\n      return pendingSearch;\n    };\n\n    /**\n     * Actual search handler\n     */\n    this.doSearch = function(value) {\n\n      //Determine search handler\n      let search;\n      if (this.options && angular.isArray(this.options)) {\n        search = searchOptions(value);\n      }\n      else if ($attrs.onSearch) {\n        search = this.onSearch({value});\n      }\n      else {\n        $log.warn('No search handler or options specified');\n        return $q.reject();\n      }\n\n      //Toggle flag\n      this.isSearching = true;\n\n      //Return search promise\n      return search\n\n        //Check if we've gotten an old search back\n        .then(results => {\n          if (++currentSearch > lastProcessedSearch) {\n            return results;\n          }\n          return $q.reject('old search');\n        })\n\n        //Process the results\n        .then(results => {\n          this.clearSelection();\n          this.results = results;\n          if (results && results.length > 0) {\n            this.isShowingResults = true;\n          }\n          lastProcessedSearch = currentSearch;\n        })\n\n        //Done searching\n        .finally(() => this.isSearching = false);\n    };\n\n    /**************************************************************************\n     * Results navigation & handling\n     ***/\n\n    /**\n     * Check if we have results\n     */\n    this.hasResults = function() {\n      return (this.results && this.results.length > 0);\n    };\n\n    /**\n     * Clear results\n     */\n    this.clearResults = function() {\n      this.results = [];\n      this.isShowingResults = false;\n    };\n\n    /**\n     * Show results\n     */\n    this.showResults = function() {\n      if (this.hasResults()) {\n        this.isShowingResults = true;\n      }\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Hide options\n      this.hideResults();\n\n      //Get the new model and label values\n      const value = getModelValue(option);\n      const label = getLabelValue(option);\n\n      //Set as search query\n      this.searchQuery = label;\n\n      //Call event handlers\n      this.onQuery({value: label});\n      this.onChange({value, option});\n    };\n\n    /**\n     * Hide results\n     */\n    this.hideResults = function() {\n      this.isShowingResults = false;\n    };\n\n    /**\n     * Set the selection index\n     */\n    this.setSelection = function(index) {\n      selectionIndex = index;\n    };\n\n    /**\n     * Check if given index is the selection index\n     */\n    this.isSelection = function(index) {\n      return (selectionIndex === index);\n    };\n\n    /**\n     * Clear selection\n     */\n    this.clearSelection = function() {\n      selectionIndex = undefined;\n    };\n\n    /**\n     * Confirm selection\n     */\n    this.confirmSelection = function(index) {\n\n      //If index not given, use current selection index\n      if (typeof index === 'undefined') {\n        index = selectionIndex;\n      }\n\n      //Validate index\n      if (\n        this.results.length === 0 ||\n        typeof this.results[index] === 'undefined') {\n        return;\n      }\n\n      //Select result\n      this.select(this.results[index]);\n    };\n  },\n});\n\n})(window, window.angular);\n"],"sourceRoot":"/source/"}