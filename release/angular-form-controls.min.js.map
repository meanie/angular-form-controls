{"version":3,"sources":["check-box.js","check-boxes.js","form-controls.js","radio-buttons.js","select-box.js","type-ahead.js"],"names":["angular","template","bindings","isInverse","controller","$onInit","$isEmpty","ngModel","$setDirty","this","onChange","value","isChecked","window","model","options","max","asObject","$element","$attrs","$log","$formControls","option","trackBy","isObject","getLabelValue","warn","labelBy","getTrackingValue","className","classes","$ctrl","isArray","modelValue","$error","required","length","min","allowInvalid","$$setOptions","$validate","toggle","index","checked","optionValue","push","i","module","hasChanged","previousValue","changes","equals","currentValue","isNullable","isDisabled","getModelValue","isSelected","nullValue","nullLabel","select","undefined","hasSpinner","$container","event","keyCode","style","$window","getComputedStyle","findOffset","relativeNode","offset","ensureDropdownInView","height","bottom","$parent","scrollTop","cTop","selectionIndex","cBottom","eTop","eBottom","oldIndex","ensureSelectionInView","findOption","phrase","KeyCodes","ENTER","ESC","SPACE","DOWN","func","delay","timeout","wrapper","isTextInput","isShowingOptions","$document","$onChanges","off","documentClickHandler","moveSelectionUp","preventDefault","showOptions","confirmSelection","hideOptions","char","getLabel","toggleOptions","selectByInput","regex","toLowerCase","find","findIndex","o","clearPhrase","setSelection","onSearch","minLength","allowNew","$scope","$q","$timeout","label","items","currentSearch","lastProcessedSearch","pendingSearch","on","focus","results","isSearching","searchQuery","keydown","moveSelectionDown","TAB","clearResults","search","doSearch","debounce","searchOptions","reject","then","finally","_this2","isShowingResults","showResults","onQuery","hideResults","clearSelection"],"mappings":"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","file":"angular-form-controls.min.js","sourcesContent":["(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('CheckBox.Component', [])\n\n/**\n * Checkbox component\n */\n.component('checkBox', {\n  template:\n    `<label class=\"CheckBox\"\n      ng-transclude\n      ng-click=\"$ctrl.toggle($event)\"\n      ng-class=\"{checked: $ctrl.isChecked(), disabled: $ctrl.isDisabled}\"\n    ></label>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  transclude: true,\n  bindings: {\n    model: '<ngModel',\n    onChange: '&',\n    isInverse: '<isInverse',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $formControls) {\n\n    //Get instance\n    let $ctrl = this;\n\n    /**\n     * On init\n     */\n    this.$onInit = function() {\n\n      //Add checkbox wrapper class to parent component\n      $element.addClass('CheckBox-Wrapper');\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isInverse) {\n          return !!$ctrl.model;\n        }\n        return !$ctrl.model;\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Toggle\n     */\n    this.toggle = function(event) {\n\n      //Don't toggle when disabled or event default prevented\n      if (this.isDisabled || event.defaultPrevented) {\n        return;\n      }\n\n      //Get boolean value and call on change handler\n      let value = !this.model;\n      this.onChange({value});\n    };\n\n    /**\n     * Check if checked\n     */\n    this.isChecked = function() {\n      return (this.isInverse ? !this.model : !!this.model);\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('CheckBoxes.Component', [])\n\n/**\n * Checkboxes component\n */\n.component('checkBoxes', {\n  template:\n    `<div class=\"CheckBox-Group {{$ctrl.classes}}\">\n      <label class=\"CheckBox\"\n        ng-repeat=\"option in $ctrl.options\"\n        ng-click=\"$ctrl.toggle(option, $index)\"\n        ng-class=\"{checked: $ctrl.isChecked(option, $index), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.getLabel(option)}}</label>\n    </div>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    min: '<',\n    max: '<',\n    onChange: '&',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $attrs, $log, $formControls) {\n\n    //Helper vars\n    let $ctrl = this;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for check boxes');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for check box tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for check boxes');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for check box label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Check if a certain option is checked\n     */\n    function isChecked(model, option, index) {\n\n      //Nothing selected?\n      if (!angular.isArray(model) || model.length === 0) {\n        return false;\n      }\n\n      //Get option value\n      let optionValue = getTrackingValue(option, index);\n\n      //See if present in model values\n      let find = model.find(model => {\n        let modelValue = getTrackingValue(model, model);\n        return (modelValue === optionValue);\n      });\n      return (typeof find !== 'undefined');\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track check boxes by index if model is an object');\n        asObject = false;\n      }\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Validation for min/max values\n      this.ngModel.$validators.min = function(modelValue) {\n        if ($ctrl.ngModel.$error.required) {\n          return true;\n        }\n        if (!$ctrl.min || $ctrl.min < 0) {\n          return true;\n        }\n        return (!angular.isArray(modelValue) || modelValue.length >= $ctrl.min);\n      };\n      this.ngModel.$validators.max = function(modelValue) {\n        if ($ctrl.ngModel.$error.required) {\n          return true;\n        }\n        if (!$ctrl.max || $ctrl.max < 0) {\n          return true;\n        }\n        return (!angular.isArray(modelValue) || modelValue.length <= $ctrl.max);\n      };\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n\n        //Needed here to prevent $validate from setting the model to undefined\n        //NOTE: first approach for Angular < 1.6.0\n        if (typeof $ctrl.ngModel.$$setOptions === 'function') {\n          $ctrl.ngModel.$$setOptions({\n            allowInvalid: true,\n          });\n        }\n        else {\n          $ctrl.ngModel.$options = $ctrl.ngModel.$options.createChild({\n            allowInvalid: true,\n          });\n        }\n\n        //Return check now\n        return (!angular.isArray($ctrl.model) || $ctrl.model.length === 0);\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        this.options = [];\n      }\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Check if given option is checked\n     */\n    this.isChecked = function(option, index) {\n      return isChecked(this.model, option, index);\n    };\n\n    /**\n     * Toggle an option\n     */\n    this.toggle = function(option, index) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Initialize value of our model array\n      let value = [];\n      if (angular.isArray(this.model)) {\n        value = this.model.map(item => item);\n      }\n\n      //Check if currently checked (use source model) and get the item value\n      let checked = isChecked(value, option, index);\n      let optionValue = getTrackingValue(option, index);\n\n      //If checked, remove from target model, otherwise add\n      if (checked) {\n        let i = value.findIndex(model => {\n          let modelValue = getTrackingValue(model, model);\n          return (modelValue === optionValue);\n        });\n        value.splice(i, 1);\n      }\n      else {\n        value.push(asObject ? option : optionValue);\n      }\n\n      //Call on change handler\n      this.onChange({value});\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('FormControls.Component', [\n  'CheckBox.Component',\n  'CheckBoxes.Component',\n  'RadioButtons.Component',\n  'SelectBox.Component',\n  'TypeAhead.Component',\n])\n\n/**\n * Helper service\n */\n.factory('$formControls', function() {\n  return {\n\n    /**\n     * Check if an item value really changed (deep checking with angular.equals)\n     */\n    hasChanged(changes) {\n\n      //Get previous and current value\n      let {previousValue, currentValue} = changes;\n\n      //If unitialized, don't trigger changes\n      if (previousValue === 'UNINITIALIZED_VALUE') {\n        return false;\n      }\n\n      //Check if equals\n      return !angular.equals(previousValue, currentValue);\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('RadioButtons.Component', [])\n\n/**\n * Radio buttons component\n */\n.component('radioButtons', {\n  template:\n    `<div class=\"RadioButton-Group {{$ctrl.classes}}\">\n      <label class=\"RadioButton\"\n        ng-if=\"$ctrl.isNullable\"\n        ng-click=\"$ctrl.select(null)\"\n        ng-class=\"{checked: $ctrl.isSelected(null), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.nullLabel}}</label>\n      <label class=\"RadioButton\"\n        ng-repeat=\"option in $ctrl.options\"\n        ng-click=\"$ctrl.select(option, $index)\"\n        ng-class=\"{checked: $ctrl.isSelected(option, $index), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.getLabel(option)}}</label>\n    </div>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    onChange: '&',\n    isNullable: '<',\n    nullValue: '<',\n    nullLabel: '<',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $attrs, $log, $formControls) {\n\n    //Helper vars\n    let $ctrl = this;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for radio buttons');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for radio tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option, index) {\n\n      //If nullable and null option given, return null value\n      if ($ctrl.isNullable && option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option, index);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullLabel;\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for selectbox');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for selectbox label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Check if a certain option is selected\n     */\n    function isSelected(option, index) {\n\n      //Nullable and null value selected?\n      if (\n        $ctrl.isNullable &&\n        $ctrl.model === $ctrl.nullValue &&\n        option === null) {\n        return true;\n      }\n\n      //Nothing selected?\n      if ($ctrl.model === null) {\n        return false;\n      }\n\n      //Get the model and option values\n      let modelValue = getTrackingValue($ctrl.model, $ctrl.model);\n      let optionValue = getTrackingValue(option, index);\n\n      //Compare the two\n      return (modelValue === optionValue);\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track radio buttons by index if model is an object');\n        asObject = false;\n      }\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isNullable) {\n          return ($ctrl.model === $ctrl.nullValue);\n        }\n        return ($ctrl.model === null || typeof $ctrl.model === 'undefined');\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        this.options = [];\n      }\n\n      //Set default null value/label if not set\n      if (typeof this.nullValue === 'undefined') {\n        this.nullValue = null;\n      }\n      if (typeof this.nullLabel === 'undefined') {\n        this.nullLabel = 'None';\n      }\n\n      //Set model to null value if not defined or null\n      if (this.isNullable) {\n        if (this.model === null || typeof this.model === 'undefined') {\n          this.model = this.nullValue;\n        }\n      }\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Check if given option is selected\n     */\n    this.isSelected = function(option, index) {\n      return isSelected(option, index);\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option, index) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Get the new model value and call on change handler\n      let value = getModelValue(option, index);\n      this.onChange({value, option});\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('SelectBox.Component', [])\n\n/**\n * Selectbox component\n */\n.component('selectBox', {\n  template:\n    `<div class=\"SelectBox {{$ctrl.classes}}\">\n      <div class=\"Input-Wrapper is-clickable\" ng-click=\"$ctrl.toggleOptions()\">\n        <div class=\"Input-Spinner\" ng-class=\"{'Input-Spinner--Visible': $ctrl.hasSpinner}\">\n          <div class=\"Caret\"\n            ng-class=\"{disabled: $ctrl.isDisabled}\"\n            ng-click=\"$event.stopPropagation()\"\n            ng-if=\"!$ctrl.hasSpinner\"\n          ></div>\n          <input readonly class=\"Input\" type=\"text\"\n            ng-value=\"$ctrl.getSelectedLabel()\"\n            ng-keydown=\"$ctrl.keydown($event)\"\n            ng-class=\"{disabled: ($ctrl.isDisabled || $ctrl.hasSpinner)}\">\n          <spinner ng-if=\"$ctrl.hasSpinner\"></spinner>\n        </div>\n      </div>\n      <ul class=\"SelectBox-Options\" ng-show=\"$ctrl.isShowingOptions\">\n        <li\n          ng-if=\"$ctrl.isNullable || !$ctrl.hasOptions()\"\n          ng-class=\"{selected: $ctrl.isSelection(-1)}\"\n          ng-mouseover=\"$ctrl.setSelection(-1)\"\n          ng-click=\"$ctrl.confirmSelection(-1); $event.preventDefault();\"\n        >{{$ctrl.nullLabel}}</li>\n        <li\n          ng-transclude\n          ng-repeat=\"option in $ctrl.options\"\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\n          ng-mouseover=\"$ctrl.setSelection($index)\"\n          ng-click=\"$ctrl.confirmSelection($index); $event.preventDefault();\"\n        >{{$ctrl.getLabel(option)}}</li>\n      </ul>\n    </div>`,\n  transclude: true,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    onChange: '&',\n    isNullable: '<',\n    nullValue: '<',\n    nullLabel: '<',\n    isDisabled: '<ngDisabled',\n    hasSpinner: '<hasSpinner',\n  },\n\n  /**\n   * Component controller\n   */\n  controller(\n    $element, $attrs, $log, $formControls, $scope, $document, $timeout, $window\n  ) {\n\n    //Helper vars\n    const $ctrl = this;\n    let selectionIndex, $input, $container;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n    let phrase = '';\n\n    //Keycodes\n    const KeyCodes = {\n      ENTER: 13,\n      ESC: 27,\n      SPACE: 32,\n      UP: 38,\n      DOWN: 40,\n    };\n\n    /**\n     * Debounce helper\n     */\n    function debounce(func, delay) {\n\n      //Timeout placeholder\n      let timeout;\n\n      //Create wrapper function\n      const wrapper = function() {\n\n        //Clear any existing timeout\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n\n        //Create new timeout\n        timeout = setTimeout(() => func(), delay);\n      };\n\n      //Return wrapper function\n      return wrapper;\n    }\n\n    /**\n     * Function to clear the phrase (debounced after 1.5 seconds)\n     */\n    const clearPhrase = debounce(() => {\n      phrase = '';\n    }, 1000);\n\n    /**\n     * Check if input was text\n     */\n    function isTextInput(event) {\n      if (event.keyCode >= 48 && event.keyCode <= 57) {\n        return true;\n      }\n      if (event.keyCode >= 65 && event.keyCode <= 90) {\n        return true;\n      }\n      if (event.keyCode === 32) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Click handler for document\n     */\n    function documentClickHandler(event) {\n      if ($ctrl.isShowingOptions && !$element[0].contains(event.target)) {\n        $scope.$apply($ctrl.hideOptions.bind($ctrl));\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    /**\n     * Find scrollable parent\n     */\n    function findScrollableParent($child) {\n\n      //Get parent\n      const $parent = $child.parent();\n      if ($parent.length === 0) {\n        return null;\n      }\n\n      //Get style\n      const style = $window.getComputedStyle($parent[0]);\n\n      //Find element that has auto overflow or which is the body\n      if ($parent[0].tagName === 'BODY' || style.overflowY === 'auto') {\n        return $parent;\n      }\n\n      //Find next\n      return findScrollableParent($parent);\n    }\n\n    /**\n     * Find offset relative to a certain node\n     */\n    function findOffset(node, relativeNode) {\n      let offset = node.offsetTop;\n      while (node.offsetParent && node.offsetParent !== relativeNode) {\n        node = node.offsetParent;\n        offset += node.offsetTop;\n      }\n      return offset;\n    }\n\n    /**\n     * Ensure the whole dropdown is in view\n     */\n    function ensureDropdownInView() {\n\n      //Find scrollable parent\n      const $parent = findScrollableParent($element);\n      if (!$parent) {\n        return;\n      }\n\n      //Get params\n      const offset = findOffset($container[0], $parent[0]);\n      const height = $parent[0].clientHeight;\n      const scroll = $parent[0].scrollTop;\n      const bottom = offset - scroll + $container[0].clientHeight;\n\n      //Check if it's outside of the height\n      if (bottom > height) {\n        const diff = bottom - height + 16;\n        $parent[0].scrollTop += diff;\n      }\n    }\n\n    /**\n     * Ensure the selected option is in view\n     */\n    function ensureSelectionInView() {\n\n      //Check index\n      if (!$ctrl.isNullable && selectionIndex < 0) {\n        return;\n      }\n\n      //Find options\n      const $options = $container.children();\n\n      //Get option now, taking into account the additional nullable element\n      const option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n      if (!option) {\n        return;\n      }\n\n      //Determine container and element top and bottom\n      const cTop = $container[0].scrollTop;\n      const cBottom = cTop + $container[0].clientHeight;\n      const eTop = option.offsetTop;\n      const eBottom = eTop + option.clientHeight;\n\n      //Check if out of view\n      if (eTop < cTop) {\n        $container[0].scrollTop -= (cTop - eTop);\n      }\n      else if (eBottom > cBottom) {\n        $container[0].scrollTop += (eBottom - cBottom);\n      }\n    }\n\n    /**\n     * Move selection up\n     */\n    function moveSelectionUp() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = $ctrl.options.length - 1;\n        }\n      }\n      else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n        selectionIndex--;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Move selection down\n     */\n    function moveSelectionDown() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = 0;\n        }\n      }\n      else if (selectionIndex < ($ctrl.options.length - 1)) {\n        selectionIndex++;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for select box');\n        return $ctrl.nullValue;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for select box tracking');\n        return $ctrl.nullValue;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option, index) {\n\n      //If nullable and null option given, return null value\n      if ($ctrl.isNullable && option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option, index);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null || typeof option === 'undefined') {\n        return $ctrl.nullLabel;\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for select box');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for select box label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Find the selected option based on the model value\n     */\n    function findOption(model, options) {\n\n      //Nothing selected or null value selected?\n      if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n        return null;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        if (typeof options[model] !== 'undefined') {\n          return options[model];\n        }\n        return null;\n      }\n\n      //Get the model value\n      let modelValue = getTrackingValue(model, model);\n\n      //Find matching option\n      return options\n        .find((option, index) => {\n          let optionValue = getTrackingValue(option, index);\n          return (modelValue === optionValue);\n        });\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track select box by index if model is an object');\n        asObject = false;\n      }\n\n      //Initialize flags\n      this.isShowingOptions = false;\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Find some elements\n      $input = $element.find('input');\n      $container = $input.parent().parent().next();\n\n      //Apply global click handler\n      //NOTE: applied on body, so that it can prevent global $document handlers\n      $document.find('body').on('click', documentClickHandler);\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isNullable) {\n          return ($ctrl.model === $ctrl.nullValue);\n        }\n        return ($ctrl.model === null || typeof $ctrl.model === 'undefined');\n      };\n    };\n\n    /**\n     * Destroy\n     */\n    this.$onDestroy = function() {\n      $document.find('body').off('click', documentClickHandler);\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        this.options = [];\n      }\n\n      //Set default null value/label if not set\n      if (typeof this.nullValue === 'undefined') {\n        this.nullValue = null;\n      }\n      if (typeof this.nullLabel === 'undefined') {\n        this.nullLabel = '...';\n      }\n\n      //Set model to null value if not defined or null\n      if (this.isNullable) {\n        if (this.model === null || typeof this.model === 'undefined') {\n          this.model = this.nullValue;\n        }\n      }\n\n      //If disabled, hide options\n      if (this.isDisabled) {\n        this.isShowingOptions = false;\n      }\n\n      //Determine selection index\n      let option = findOption(this.model, this.options);\n      selectionIndex = this.options.indexOf(option);\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Keydown handler for input element\n     */\n    this.keydown = function(event) {\n\n      //Move selection up or down\n      if (event.keyCode === KeyCodes.UP) {\n        event.preventDefault();\n        if (this.isShowingOptions) {\n          moveSelectionUp();\n        }\n        else {\n          this.showOptions();\n        }\n      }\n      else if (event.keyCode === KeyCodes.DOWN) {\n        event.preventDefault();\n        if (this.isShowingOptions) {\n          moveSelectionDown();\n        }\n        else {\n          this.showOptions();\n        }\n      }\n\n      //Confirm selection\n      else if (event.keyCode === KeyCodes.ENTER && this.isShowingOptions) {\n        event.preventDefault();\n        this.confirmSelection();\n      }\n\n      //Hide options\n      else if (event.keyCode === KeyCodes.ESC && this.isShowingOptions) {\n        event.preventDefault();\n        this.hideOptions();\n      }\n\n      //Show options\n      else if (event.keyCode === KeyCodes.ENTER && !this.isShowingOptions) {\n        event.preventDefault();\n        this.showOptions();\n      }\n\n      //Text input\n      else if (isTextInput(event)) {\n        const char = String.fromCharCode(event.keyCode);\n        this.selectByInput(char);\n      }\n    };\n\n    /**\n     * Get label value of selected option\n     */\n    this.getSelectedLabel = function() {\n      let option = findOption(this.model, this.options);\n      return getLabelValue(option);\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Show options\n     */\n    this.showOptions = function() {\n      if (!this.isDisabled && !this.hasSpinner) {\n        this.isShowingOptions = true;\n        $timeout(() => {\n          ensureDropdownInView();\n        });\n      }\n    };\n\n    /**\n     * Hide options\n     */\n    this.hideOptions = function() {\n      this.isShowingOptions = false;\n    };\n\n    /**\n     * Toggle options\n     */\n    this.toggleOptions = function() {\n      if (this.isShowingOptions) {\n        this.hideOptions();\n      }\n      else {\n        this.showOptions();\n      }\n    };\n\n    /**\n     * Has options check\n     */\n    this.hasOptions = function() {\n      return (this.options.length > 0);\n    };\n\n    /**\n     * Select by input character(s)\n     */\n    this.selectByInput = function(char) {\n\n      //Lowercase all the things\n      char = char.toLowerCase();\n\n      //Add to phrase\n      phrase += char;\n\n      //Create regex\n      const regex = new RegExp('^' + phrase, 'i');\n\n      //Find matching option\n      const option = this.options.find(option => {\n        const label = getLabelValue(option);\n        return label.match(regex);\n      });\n\n      //Match found?\n      if (option) {\n        const index = this.options.findIndex(o => o === option);\n        this.select(option, index, true);\n      }\n\n      //Clear phrase (debounced)\n      clearPhrase();\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option, index, leaveOpen) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Hide options\n      if (!leaveOpen) {\n        this.hideOptions();\n      }\n      else {\n        ensureSelectionInView();\n      }\n\n      //Get the new model value and call on change handler\n      let value = getModelValue(option, index);\n      this.onChange({value, option});\n    };\n\n    /**\n     * Set the selection index\n     */\n    this.setSelection = function(index) {\n      selectionIndex = index;\n    };\n\n    /**\n     * Check if given index is the selection index\n     */\n    this.isSelection = function(index) {\n      return (selectionIndex === index);\n    };\n\n    /**\n     * Confirm selection\n     */\n    this.confirmSelection = function(index) {\n\n      //If index not given, use current selection index\n      if (typeof index === 'undefined') {\n        index = selectionIndex;\n      }\n\n      //Initialize option\n      let option;\n\n      //Nullable and -1 index given?\n      if (this.isNullable && index === -1) {\n        option = null;\n      }\n\n      //Otherwise, take from given options\n      else {\n\n        //Validate index\n        if (\n          !this.hasOptions() ||\n          typeof index === 'undefined' ||\n          typeof this.options[index] === 'undefined'\n        ) {\n          return;\n        }\n\n        //Get option\n        option = this.options[index];\n      }\n\n      //Select option now\n      this.select(option, index);\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('TypeAhead.Component', [])\n\n/**\n * Type ahead component\n */\n.component('typeAhead', {\n  template:\n    `<div class=\"TypeAhead\">\n      <span class=\"Input-Spinner\"\n        ng-class=\"{'Input-Spinner--Visible': $ctrl.isSearching}\">\n        <input class=\"Input\" type=\"text\"\n          placeholder=\"{{$ctrl.placeholder}}\"\n          ng-keydown=\"$ctrl.keydown($event)\"\n          ng-keyup=\"$ctrl.keyup($event)\"\n          ng-disabled=\"$ctrl.isDisabled\"\n          ng-model=\"$ctrl.searchQuery\">\n        <spinner></spinner>\n      </span>\n      <ul class=\"TypeAhead-Results\" ng-show=\"$ctrl.isShowingResults\">\n        <li\n          ng-repeat=\"item in $ctrl.results\"\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\n          ng-mouseover=\"$ctrl.setSelection($index)\"\n          ng-click=\"$ctrl.confirmSelection($index)\"\n          ng-transclude>\n          <span ng-bind-html=\"$ctrl.getLabel(item) |\n            markmatches:$ctrl.searchQuery:'strong'\"></span>\n        </li>\n      </ul>\n    </div>`,\n  transclude: true,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    placeholder: '@',\n    onSearch: '&',\n    onChange: '&',\n    onQuery: '&',\n    isDisabled: '<ngDisabled',\n    labelBy: '@',\n    trackBy: '@',\n    asObject: '@',\n    minLength: '@',\n    allowNew: '@',\n  },\n\n  /**\n   * Component controller\n   */\n  controller(\n    $element, $scope, $formControls, $attrs, $log, $q, $timeout, $document\n  ) {\n\n    //Helper vars\n    let $input, $container, $options;\n    let $ctrl = this;\n    let selectionIndex = -1;\n    let debounce = 100;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n    let allowNew = ($attrs.allowNew === 'true');\n\n    //Keep track of searches, prevent older searches overwriting newer ones\n    let currentSearch = 0;\n    let lastProcessedSearch = 0;\n    let pendingSearch = null;\n\n    //Keycodes\n    const KeyCodes = {\n      ENTER: 13,\n      ESC: 27,\n      SPACE: 32,\n      TAB: 9,\n      UP: 38,\n      DOWN: 40,\n    };\n\n    /**\n     * Check if input was control\n     */\n    function isControlInput(event) {\n      let keys = [\n        KeyCodes.UP, KeyCodes.DOWN, KeyCodes.ENTER, KeyCodes.ESC, KeyCodes.TAB,\n      ];\n      return (keys.indexOf(event.keyCode) > -1);\n    }\n\n    /**\n     * Click handler for document\n     */\n    function documentClickHandler(event) {\n      if (!$input[0].contains(event.target) && $ctrl.isShowingResults) {\n        $scope.$apply($ctrl.hideResults.bind($ctrl));\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    /**\n     * Ensure the selected option is in view\n     */\n    function ensureSelectionInView() {\n\n      //Check index\n      if (!$ctrl.isNullable && selectionIndex < 0) {\n        return;\n      }\n\n      //Get option now, taking into account the additional nullable element\n      let option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n      if (!option) {\n        return;\n      }\n\n      //Determine container and element top and bottom\n      let cTop = $container[0].scrollTop;\n      let cBottom = cTop + $container[0].clientHeight;\n      let eTop = option.offsetTop;\n      let eBottom = eTop + option.clientHeight;\n\n      //Check if out of view\n      if (eTop < cTop) {\n        $container[0].scrollTop -= (cTop - eTop);\n      }\n      else if (eBottom > cBottom) {\n        $container[0].scrollTop += (eBottom - cBottom);\n      }\n    }\n\n    /**\n     * Move selection up\n     */\n    function moveSelectionUp() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = $ctrl.options.length - 1;\n        }\n      }\n      else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n        selectionIndex--;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Move selection down\n     */\n    function moveSelectionDown() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = 0;\n        }\n      }\n      else if (selectionIndex < ($ctrl.options.length - 1)) {\n        selectionIndex++;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option) {\n\n      //Non object? Track by its value\n      if (option === null || !angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for type ahead');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for type ahead tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option) {\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null || typeof option === 'undefined') {\n        return '';\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for type ahead');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for type ahead label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Find the selected option based on the model value\n     */\n    function findOption(model, options) {\n\n      //Nothing selected or null value selected?\n      if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n        return null;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        if (typeof options[model] !== 'undefined') {\n          return options[model];\n        }\n        return null;\n      }\n\n      //Get the model value\n      let modelValue = getTrackingValue(model, model);\n\n      //Find matching option\n      return options\n        .find((option, index) => {\n          let optionValue = getTrackingValue(option, index);\n          return (modelValue === optionValue);\n        });\n    }\n\n    /**\n     * Do a simple search on object property\n     */\n    function searchOptions(value) {\n      if (!value) {\n        return $q.resolve([]);\n      }\n      let regex = new RegExp('(?:^|\\\\b)(' + value + ')', 'i');\n      let items = $ctrl.options\n        .filter(option => {\n          let label = getLabelValue(option);\n          return regex.test(label);\n        });\n      return $q.resolve(items);\n    }\n\n    /**\n     * Init\n     */\n    this.$onInit = function() {\n\n      //Find some elements\n      $input = $element.find('input');\n      $container = $input.parent().next();\n      $options = $container.find('li');\n\n      //Propagate focus\n      $element.attr('tabindex', -1);\n      $element.on('focus', () => {\n        $input[0].focus();\n      });\n\n      //Apply document click handler\n      //NOTE: applied on body, so that it can prevent global $document handlers\n      $document.find('body').on('click', documentClickHandler);\n\n      //Initialize results and flags\n      this.results = [];\n      this.isSearching = false;\n      this.isShowingResults = false;\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.model === null || typeof $ctrl.model === 'undefined') {\n          if (allowNew && $ctrl.searchQuery) {\n            return false;\n          }\n          return true;\n        }\n        return false;\n      };\n    };\n\n    /**\n     * Destroy\n     */\n    this.$onDestroy = function() {\n      $document.find('body').off('click', documentClickHandler);\n    };\n\n    /**\n     * Change handler\n     */\n    this.$onChanges = function(changes) {\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n\n        //Only update search query when we have a model\n        //This is to prevent the input from being cleared when we go and edit\n        if (this.model) {\n          let option;\n          if (angular.isArray(this.options)) {\n            option = findOption(this.model, this.options);\n          }\n          else if (angular.isObject(this.model)) {\n            option = this.model;\n          }\n          if (option) {\n            this.searchQuery = getLabelValue(option);\n          }\n        }\n\n        //Validate model\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Key down handler\n     */\n    this.keydown = function(event) {\n\n      //Arrows up/down, move selection\n      if (this.isShowingResults && isControlInput(event)) {\n        if (event.keyCode === KeyCodes.UP) {\n          event.preventDefault();\n          moveSelectionUp();\n        }\n        else if (event.keyCode === KeyCodes.DOWN) {\n          event.preventDefault();\n          moveSelectionDown();\n        }\n        else if (event.keyCode === KeyCodes.ESC) {\n          event.preventDefault();\n          this.hideResults();\n        }\n        else if (event.keyCode === KeyCodes.TAB) {\n          //Don't prevent default\n          this.hideResults();\n        }\n        else if (event.keyCode === KeyCodes.ENTER) {\n          event.preventDefault();\n          this.confirmSelection();\n        }\n      }\n\n      //Show options\n      else if (event.keyCode === KeyCodes.ENTER) {\n        event.preventDefault();\n        this.showResults();\n      }\n    };\n\n    /**\n     * Key up handler\n     */\n    this.keyup = function(event) {\n\n      //If control input, skip further handling\n      if (isControlInput(event)) {\n        return;\n      }\n\n      //Get search query\n      let value = (this.searchQuery || '').trim();\n\n      //Call event handlers\n      this.onQuery({value});\n      this.onChange({value: null, option: null});\n\n      //Validate and mark as dirty\n      this.ngModel.$validate();\n      this.ngModel.$setDirty();\n\n      //Should we search?\n      if (!this.minLength || value.length >= this.minLength) {\n        this.search(value);\n      }\n      else if (this.hasResults()) {\n        this.clearResults();\n        this.clearSelection();\n      }\n    };\n\n    /**************************************************************************\n     * Search\n     ***/\n\n    /**\n     * Search wrapper\n     */\n    this.search = function(value) {\n\n      //Create new debounced search\n      pendingSearch = $timeout(() => {\n        pendingSearch = null;\n        return this.doSearch(value);\n      }, debounce);\n\n      //Return the promise\n      return pendingSearch;\n    };\n\n    /**\n     * Actual search handler\n     */\n    this.doSearch = function(value) {\n\n      //Determine search handler\n      let search;\n      if (this.options && angular.isArray(this.options)) {\n        search = searchOptions(value);\n      }\n      else if ($attrs.onSearch) {\n        search = this.onSearch({value});\n      }\n      else {\n        $log.warn('No search handler or options specified');\n        return $q.reject();\n      }\n\n      //Toggle flag\n      this.isSearching = true;\n\n      //Return search promise\n      return search\n\n        //Check if we've gotten an old search back\n        .then(results => {\n          if (++currentSearch > lastProcessedSearch) {\n            return results;\n          }\n          return $q.reject('old search');\n        })\n\n        //Process the results\n        .then(results => {\n          this.clearSelection();\n          this.results = results;\n          if (results && results.length > 0) {\n            this.isShowingResults = true;\n          }\n        })\n\n        //Done searching\n        .finally(() => this.isSearching = false);\n    };\n\n    /**************************************************************************\n     * Results navigation & handling\n     ***/\n\n    /**\n     * Check if we have results\n     */\n    this.hasResults = function() {\n      return (this.results && this.results.length > 0);\n    };\n\n    /**\n     * Clear results\n     */\n    this.clearResults = function() {\n      this.results = [];\n      this.isShowingResults = false;\n    };\n\n    /**\n     * Show results\n     */\n    this.showResults = function() {\n      if (this.hasResults()) {\n        this.isShowingResults = true;\n      }\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Hide options\n      this.hideResults();\n\n      //Get the new model and label values\n      let value = getModelValue(option);\n      let label = getLabelValue(option);\n\n      //Set as search query\n      this.searchQuery = label;\n\n      //Call event handlers\n      this.onQuery({value: label});\n      this.onChange({value, option});\n    };\n\n    /**\n     * Hide results\n     */\n    this.hideResults = function() {\n      this.isShowingResults = false;\n    };\n\n    /**\n     * Set the selection index\n     */\n    this.setSelection = function(index) {\n      selectionIndex = index;\n    };\n\n    /**\n     * Check if given index is the selection index\n     */\n    this.isSelection = function(index) {\n      return (selectionIndex === index);\n    };\n\n    /**\n     * Clear selection\n     */\n    this.clearSelection = function() {\n      selectionIndex = undefined;\n    };\n\n    /**\n     * Confirm selection\n     */\n    this.confirmSelection = function(index) {\n\n      //If index not given, use current selection index\n      if (typeof index === 'undefined') {\n        index = selectionIndex;\n      }\n\n      //Validate index\n      if (\n        this.results.length === 0 ||\n        typeof this.results[index] === 'undefined') {\n        return;\n      }\n\n      //Select result\n      this.select(this.results[index]);\n    };\n  },\n});\n\n})(window, window.angular);\n"]}