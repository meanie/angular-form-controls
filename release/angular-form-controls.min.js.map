{"version":3,"sources":["check-box.js","check-boxes.js","form-controls.js","radio-buttons.js","select-box.js","type-ahead.js"],"names":["angular","template","bindings","isInverse","controller","$element","$label","find","on","$ctrl","focus","ngModel","$setDirty","this","onChange","value","isChecked","window","model","options","max","asObject","$attrs","$log","$formControls","option","trackBy","isObject","getLabelValue","warn","labelBy","getTrackingValue","className","classes","isArray","modelValue","$error","required","length","min","allowInvalid","$$setOptions","toggle","index","checked","optionValue","push","i","module","hasChanged","previousValue","changes","equals","currentValue","isNullable","isDisabled","getModelValue","isSelected","nullValue","nullLabel","$validate","select","undefined","inputClass","filter","hasSpinner","$filter","$scope","$document","$timeout","$window","event","keyCode","style","getComputedStyle","findOffset","relativeNode","offset","ensureDropdownInView","$parent","$container","next","bottom","height","scrollTop","isShowingOptions","$options","children","$input","parent","cTop","selectionIndex","cBottom","eTop","eBottom","oldIndex","ensureSelectionInView","findOption","phrase","ENTER","ESC","UP","DOWN","func","delay","timeout","wrapper","isTextInput","$onChanges","off","documentClickHandler","moveSelectionUp","debounce","preventDefault","showOptions","confirmSelection","hideOptions","char","getLabel","toggleOptions","selectByInput","regex","toLowerCase","findIndex","String","o","clearPhrase","setSelection","placeholder","onSearch","onQuery","minLength","allowNew","$q","isShowingResults","label","$onInit","items","currentSearch","lastProcessedSearch","pendingSearch","TAB","LEFT","SHIFT","CTRL","ALT","CAPSLOCK","CMDLEFT","CMDRIGHT","isControlInput","attr","typeAheadClass","results","isSearching","searchQuery","keydown","moveSelectionDown","cancel","hasResults","search","doSearch","_this","searchOptions","reject","then","finally","clearResults","showResults","hideResults","clearSelection"],"mappings":"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","file":"angular-form-controls.min.js","sourcesContent":["(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('CheckBox.Component', [])\n\n/**\n * Checkbox component\n */\n.component('checkBox', {\n  template:\n    `<label class=\"CheckBox {{$ctrl.classes}}\"\n      ng-transclude\n      ng-click=\"$ctrl.toggle($event)\"\n      ng-class=\"{checked: $ctrl.isChecked(), disabled: $ctrl.isDisabled}\"\n    ></label>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  transclude: true,\n  bindings: {\n    model: '<ngModel',\n    onChange: '&',\n    isInverse: '<isInverse',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $formControls) {\n\n    //Get instance\n    let $ctrl = this;\n\n    /**\n     * On init\n     */\n    this.$onInit = function() {\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Add checkbox wrapper class to parent component\n      $element.addClass('CheckBoxWrapper');\n\n      //Find label\n      const $label = $element.find('label');\n\n      //Propagate focus\n      $element.on('focus', () => {\n        $label[0].focus();\n      });\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isInverse) {\n          return !!$ctrl.model;\n        }\n        return !$ctrl.model;\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Toggle\n     */\n    this.toggle = function(event) {\n\n      //Don't toggle when disabled or event default prevented\n      if (this.isDisabled || event.defaultPrevented) {\n        return;\n      }\n\n      //Get boolean value and call on change handler\n      let value = !this.model;\n      this.onChange({value});\n    };\n\n    /**\n     * Check if checked\n     */\n    this.isChecked = function() {\n      return (this.isInverse ? !this.model : !!this.model);\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('CheckBoxes.Component', [])\n\n/**\n * Checkboxes component\n */\n.component('checkBoxes', {\n  template:\n    `<div class=\"CheckBoxGroup {{$ctrl.classes}}\">\n      <label class=\"CheckBox\"\n        ng-repeat=\"option in $ctrl.options\"\n        ng-click=\"$ctrl.toggle(option, $index)\"\n        ng-class=\"{checked: $ctrl.isChecked(option, $index), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.getLabel(option)}}</label>\n    </div>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    min: '<',\n    max: '<',\n    onChange: '&',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $attrs, $log, $formControls) {\n\n    //Helper vars\n    let $ctrl = this;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for check boxes');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for check box tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for check boxes');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for check box label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Check if a certain option is checked\n     */\n    function isChecked(model, option, index) {\n\n      //Nothing selected?\n      if (!angular.isArray(model) || model.length === 0) {\n        return false;\n      }\n\n      //Get option value\n      let optionValue = getTrackingValue(option, index);\n\n      //See if present in model values\n      let find = model.find(model => {\n        let modelValue = getTrackingValue(model, model);\n        return (modelValue === optionValue);\n      });\n      return (typeof find !== 'undefined');\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track check boxes by index if model is an object');\n        asObject = false;\n      }\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Validation for min/max values\n      this.ngModel.$validators.min = function(modelValue) {\n        if ($ctrl.ngModel.$error.required) {\n          return true;\n        }\n        if (!$ctrl.min || $ctrl.min < 0) {\n          return true;\n        }\n        return (!angular.isArray(modelValue) || modelValue.length >= $ctrl.min);\n      };\n      this.ngModel.$validators.max = function(modelValue) {\n        if ($ctrl.ngModel.$error.required) {\n          return true;\n        }\n        if (!$ctrl.max || $ctrl.max < 0) {\n          return true;\n        }\n        return (!angular.isArray(modelValue) || modelValue.length <= $ctrl.max);\n      };\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n\n        //Needed here to prevent $validate from setting the model to undefined\n        //NOTE: first approach for Angular < 1.6.0\n        if (typeof $ctrl.ngModel.$$setOptions === 'function') {\n          $ctrl.ngModel.$$setOptions({\n            allowInvalid: true,\n          });\n        }\n        else {\n          $ctrl.ngModel.$options = $ctrl.ngModel.$options.createChild({\n            allowInvalid: true,\n          });\n        }\n\n        //Return check now\n        return (!angular.isArray($ctrl.model) || $ctrl.model.length === 0);\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          const options = this.options.split('\\n');\n          const set = new Set(options);\n          this.options = Array.from(set.values());\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Check if given option is checked\n     */\n    this.isChecked = function(option, index) {\n      return isChecked(this.model, option, index);\n    };\n\n    /**\n     * Toggle an option\n     */\n    this.toggle = function(option, index) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Initialize value of our model array\n      let value = [];\n      if (angular.isArray(this.model)) {\n        value = this.model.map(item => item);\n      }\n\n      //Check if currently checked (use source model) and get the item value\n      let checked = isChecked(value, option, index);\n      let optionValue = getTrackingValue(option, index);\n\n      //If checked, remove from target model, otherwise add\n      if (checked) {\n        let i = value.findIndex(model => {\n          let modelValue = getTrackingValue(model, model);\n          return (modelValue === optionValue);\n        });\n        value.splice(i, 1);\n      }\n      else {\n        value.push(asObject ? option : optionValue);\n      }\n\n      //Call on change handler\n      this.onChange({value});\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('FormControls.Component', [\n  'CheckBox.Component',\n  'CheckBoxes.Component',\n  'RadioButtons.Component',\n  'SelectBox.Component',\n  'TypeAhead.Component',\n])\n\n/**\n * Helper service\n */\n.factory('$formControls', function() {\n  return {\n\n    /**\n     * Check if an item value really changed (deep checking with angular.equals)\n     */\n    hasChanged(changes) {\n\n      //Get previous and current value\n      let {previousValue, currentValue} = changes;\n\n      //If unitialized, don't trigger changes\n      if (previousValue === 'UNINITIALIZED_VALUE') {\n        return false;\n      }\n\n      //Check if equals\n      return !angular.equals(previousValue, currentValue);\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('RadioButtons.Component', [])\n\n/**\n * Radio buttons component\n */\n.component('radioButtons', {\n  template:\n    `<div class=\"RadioButtonGroup {{$ctrl.classes}}\">\n      <label class=\"RadioButton\"\n        ng-if=\"$ctrl.isNullable\"\n        ng-click=\"$ctrl.select(null)\"\n        ng-class=\"{checked: $ctrl.isSelected(null), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.nullLabel}}</label>\n      <label class=\"RadioButton\"\n        ng-repeat=\"option in $ctrl.options\"\n        ng-click=\"$ctrl.select(option, $index)\"\n        ng-class=\"{checked: $ctrl.isSelected(option, $index), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.getLabel(option)}}</label>\n    </div>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    onChange: '&',\n    isNullable: '<',\n    nullValue: '<',\n    nullLabel: '<',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $attrs, $log, $formControls) {\n\n    //Helper vars\n    let $ctrl = this;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for radio buttons');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for radio tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option, index) {\n\n      //If nullable and null option given, return null value\n      if ($ctrl.isNullable && option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option, index);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullLabel;\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for selectbox');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for selectbox label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Check if a certain option is selected\n     */\n    function isSelected(option, index) {\n\n      //Nullable and null value selected?\n      if (\n        $ctrl.isNullable &&\n        $ctrl.model === $ctrl.nullValue &&\n        option === null) {\n        return true;\n      }\n\n      //Nothing selected?\n      if ($ctrl.model === null) {\n        return false;\n      }\n\n      //Get the model and option values\n      let modelValue = getTrackingValue($ctrl.model, $ctrl.model);\n      let optionValue = getTrackingValue(option, index);\n\n      //Compare the two\n      return (modelValue === optionValue);\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track radio buttons by index if model is an object');\n        asObject = false;\n      }\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isNullable) {\n          return ($ctrl.model === $ctrl.nullValue);\n        }\n        return (\n          $ctrl.model === null ||\n          $ctrl.model === $ctrl.nullValue ||\n          typeof $ctrl.model === 'undefined'\n        );\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          const options = this.options.split('\\n');\n          const set = new Set(options);\n          this.options = Array.from(set.values());\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Set default null value/label if not set\n      if (typeof this.nullValue === 'undefined') {\n        this.nullValue = null;\n      }\n      if (typeof this.nullLabel === 'undefined') {\n        this.nullLabel = 'None';\n      }\n\n      //Set model to null value if not defined or null\n      if (this.isNullable) {\n        if (this.model === null || typeof this.model === 'undefined') {\n          this.model = this.nullValue;\n        }\n      }\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Check if given option is selected\n     */\n    this.isSelected = function(option, index) {\n      return isSelected(option, index);\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option, index) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Get the new model value and call on change handler\n      let value = getModelValue(option, index);\n      this.onChange({value, option});\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('SelectBox.Component', [])\n\n/**\n * Selectbox component\n */\n.component('selectBox', {\n  template:\n    `<div class=\"SelectBox {{$ctrl.selectBoxClass}}\">\n      <div class=\"InputWrapper is-clickable\" ng-click=\"$ctrl.toggleOptions()\">\n        <div class=\"Caret\"\n          ng-class=\"{disabled: $ctrl.isDisabled}\"\n          ng-click=\"$event.stopPropagation(); $ctrl.toggleOptions();\"\n          ng-if=\"!$ctrl.hasSpinner\"\n        ></div>\n        <input readonly class=\"Input {{$ctrl.inputClass}}\" type=\"text\"\n          ng-value=\"$ctrl.getSelectedLabel()\"\n          ng-keydown=\"$ctrl.keydown($event)\"\n          ng-class=\"{disabled: ($ctrl.isDisabled || $ctrl.hasSpinner)}\">\n        <spinner class=\"Spinner--input\" ng-if=\"$ctrl.hasSpinner\"></spinner>\n      </div>\n      <ul class=\"SelectBox-options\" ng-if=\"$ctrl.isShowingOptions\">\n        <li\n          ng-if=\"$ctrl.isNullable || !$ctrl.hasOptions()\"\n          ng-class=\"{selected: $ctrl.isSelection(-1)}\"\n          ng-mouseover=\"$ctrl.setSelection(-1)\"\n          ng-click=\"$ctrl.confirmSelection(-1); $event.preventDefault();\"\n        >{{$ctrl.nullLabel}}</li>\n        <li\n          ng-transclude\n          ng-repeat=\"option in $ctrl.options\"\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\n          ng-mouseover=\"$ctrl.setSelection($index)\"\n          ng-click=\"$ctrl.confirmSelection($index); $event.preventDefault();\"\n        >{{$ctrl.getLabel(option)}}</li>\n      </ul>\n    </div>`,\n  transclude: true,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    onChange: '&',\n    isNullable: '<',\n    nullValue: '<',\n    nullLabel: '<',\n    inputClass: '@',\n    filter: '@',\n    isDisabled: '<ngDisabled',\n    hasSpinner: '<hasSpinner',\n  },\n\n  /**\n   * Component controller\n   */\n  controller(\n    $element, $attrs, $log, $filter, $formControls, $scope,\n    $document, $timeout, $window\n  ) {\n\n    //Helper vars\n    const $ctrl = this;\n    let selectionIndex, $input;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n    let phrase = '';\n\n    //Keycodes\n    const ENTER = 13;\n    const ESC = 27;\n    const UP = 38;\n    const DOWN = 40;\n\n    /**\n     * Debounce helper\n     */\n    function debounce(func, delay) {\n\n      //Timeout placeholder\n      let timeout;\n\n      //Create wrapper function\n      const wrapper = function() {\n\n        //Clear any existing timeout\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n\n        //Create new timeout\n        timeout = setTimeout(() => func(), delay);\n      };\n\n      //Return wrapper function\n      return wrapper;\n    }\n\n    /**\n     * Function to clear the phrase (debounced after 1.5 seconds)\n     */\n    const clearPhrase = debounce(() => {\n      phrase = '';\n    }, 1000);\n\n    /**\n     * Check if input was text\n     */\n    function isTextInput(event) {\n      if (event.keyCode >= 48 && event.keyCode <= 57) {\n        return true;\n      }\n      if (event.keyCode >= 65 && event.keyCode <= 90) {\n        return true;\n      }\n      if (event.keyCode === 32) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Click handler for document\n     */\n    function documentClickHandler(event) {\n      if ($ctrl.isShowingOptions && !$element[0].contains(event.target)) {\n        $scope.$apply($ctrl.hideOptions.bind($ctrl));\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    /**\n     * Find scrollable parent\n     */\n    function findScrollableParent($child) {\n\n      //Get parent\n      const $parent = $child.parent();\n      if ($parent.length === 0) {\n        return null;\n      }\n\n      //Get style\n      const style = $window.getComputedStyle($parent[0]);\n\n      //Find element that has auto overflow or which is the body\n      if ($parent[0].tagName === 'BODY' || style.overflowY === 'auto') {\n        return $parent;\n      }\n\n      //Find next\n      return findScrollableParent($parent);\n    }\n\n    /**\n     * Find offset relative to a certain node\n     */\n    function findOffset(node, relativeNode) {\n      let offset = node.offsetTop;\n      while (node.offsetParent && node.offsetParent !== relativeNode) {\n        node = node.offsetParent;\n        offset += node.offsetTop;\n      }\n      return offset;\n    }\n\n    /**\n     * Ensure the whole dropdown is in view\n     */\n    function ensureDropdownInView() {\n\n      //Only if open\n      if (!$ctrl.isShowingOptions) {\n        return;\n      }\n\n      //Find scrollable parent\n      const $parent = findScrollableParent($element);\n      if (!$parent) {\n        return;\n      }\n\n      //Get params\n      const $container = $input.parent().next();\n      const offset = findOffset($container[0], $parent[0]);\n      const height = $parent[0].clientHeight;\n      const scroll = $parent[0].scrollTop;\n      const bottom = offset - scroll + $container[0].clientHeight;\n\n      //Check if it's outside of the height\n      if (bottom > height) {\n        const diff = bottom - height + 16;\n        $parent[0].scrollTop += diff;\n      }\n    }\n\n    /**\n     * Ensure the selected option is in view\n     */\n    function ensureSelectionInView() {\n\n      //Only if open\n      if (!$ctrl.isShowingOptions) {\n        return;\n      }\n\n      //Check index\n      if (!$ctrl.isNullable && selectionIndex < 0) {\n        return;\n      }\n\n      //Find options\n      const $container = $input.parent().next();\n      const $options = $container.children();\n\n      //Get option now, taking into account the additional nullable element\n      const option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n      if (!option) {\n        return;\n      }\n\n      //Determine container and element top and bottom\n      const cTop = $container[0].scrollTop;\n      const cBottom = cTop + $container[0].clientHeight;\n      const eTop = option.offsetTop;\n      const eBottom = eTop + option.clientHeight;\n\n      //Check if out of view\n      if (eTop < cTop) {\n        $container[0].scrollTop -= (cTop - eTop);\n      }\n      else if (eBottom > cBottom) {\n        $container[0].scrollTop += (eBottom - cBottom);\n      }\n    }\n\n    /**\n     * Move selection up\n     */\n    function moveSelectionUp() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = $ctrl.options.length - 1;\n        }\n      }\n      else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n        selectionIndex--;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Move selection down\n     */\n    function moveSelectionDown() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = 0;\n        }\n      }\n      else if (selectionIndex < ($ctrl.options.length - 1)) {\n        selectionIndex++;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for select box');\n        return $ctrl.nullValue;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for select box tracking');\n        return $ctrl.nullValue;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option, index) {\n\n      //If nullable and null option given, return null value\n      if ($ctrl.isNullable && option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option, index);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null || typeof option === 'undefined') {\n        return $ctrl.nullLabel;\n      }\n\n      //Non object? Use its value, filtering if needed\n      if (!angular.isObject(option)) {\n        if ($ctrl.$filter) {\n          return $ctrl.$filter(option);\n        }\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for select box');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for select box label');\n        return '';\n      }\n\n      //Return the property, filtering if needed\n      if ($ctrl.$filter) {\n        return $ctrl.$filter(option[labelBy]);\n      }\n      return option[labelBy];\n    }\n\n    /**\n     * Find the selected option based on the model value\n     */\n    function findOption(model, options) {\n\n      //Nothing selected or null value selected?\n      if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n        return null;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        if (typeof options[model] !== 'undefined') {\n          return options[model];\n        }\n        return null;\n      }\n\n      //Get the model value\n      let modelValue = getTrackingValue(model, model);\n\n      //Find matching option\n      return options\n        .find((option, index) => {\n          let optionValue = getTrackingValue(option, index);\n          return (modelValue === optionValue);\n        });\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track select box by index if model is an object');\n        asObject = false;\n      }\n\n      //Initialize flags\n      this.isShowingOptions = false;\n\n      //Resolve filter\n      if (this.filter) {\n        this.$filter = $filter(this.filter);\n      }\n\n      //Propagate classes\n      this.selectBoxClass = $element[0].className;\n      $element[0].className = '';\n\n      //Find input\n      $input = $element.find('input');\n\n      //Apply global click handler\n      //NOTE: applied on body, so that it can prevent global $document handlers\n      $document.find('body').on('click', documentClickHandler);\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isNullable) {\n          return ($ctrl.model === $ctrl.nullValue);\n        }\n        return (\n          $ctrl.model === null ||\n          $ctrl.model === $ctrl.nullValue ||\n          typeof $ctrl.model === 'undefined'\n        );\n      };\n    };\n\n    /**\n     * Destroy\n     */\n    this.$onDestroy = function() {\n      $document.find('body').off('click', documentClickHandler);\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          const options = this.options.split('\\n');\n          const set = new Set(options);\n          this.options = Array.from(set.values());\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Set default null value/label if not set\n      if (typeof this.nullValue === 'undefined') {\n        this.nullValue = null;\n      }\n      if (typeof this.nullLabel === 'undefined') {\n        this.nullLabel = '...';\n      }\n\n      //Set model to null value if not defined or null\n      if (this.isNullable) {\n        if (this.model === null || typeof this.model === 'undefined') {\n          this.model = this.nullValue;\n        }\n      }\n\n      //If disabled, hide options\n      if (this.isDisabled) {\n        this.isShowingOptions = false;\n      }\n\n      //Determine selection index\n      let option = findOption(this.model, this.options);\n      selectionIndex = this.options.indexOf(option);\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Keydown handler for input element\n     */\n    this.keydown = function(event) {\n\n      //Move selection up or down\n      if (event.keyCode === UP) {\n        event.preventDefault();\n        if (this.isShowingOptions) {\n          moveSelectionUp();\n        }\n        else {\n          this.showOptions();\n        }\n      }\n      else if (event.keyCode === DOWN) {\n        event.preventDefault();\n        if (this.isShowingOptions) {\n          moveSelectionDown();\n        }\n        else {\n          this.showOptions();\n        }\n      }\n\n      //Confirm selection\n      else if (event.keyCode === ENTER && this.isShowingOptions) {\n        event.preventDefault();\n        this.confirmSelection();\n      }\n\n      //Hide options\n      else if (event.keyCode === ESC && this.isShowingOptions) {\n        event.preventDefault();\n        this.hideOptions();\n      }\n\n      //Show options\n      else if (event.keyCode === ENTER && !this.isShowingOptions) {\n        event.preventDefault();\n        this.showOptions();\n      }\n\n      //Text input\n      else if (isTextInput(event)) {\n        const char = String.fromCharCode(event.keyCode);\n        this.selectByInput(char);\n      }\n    };\n\n    /**\n     * Get label value of selected option\n     */\n    this.getSelectedLabel = function() {\n      let option = findOption(this.model, this.options);\n      return getLabelValue(option);\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Show options\n     */\n    this.showOptions = function() {\n      if (!this.isDisabled && !this.hasSpinner) {\n        this.isShowingOptions = true;\n        $timeout(() => {\n          ensureDropdownInView();\n          ensureSelectionInView();\n        });\n      }\n    };\n\n    /**\n     * Hide options\n     */\n    this.hideOptions = function() {\n      this.isShowingOptions = false;\n    };\n\n    /**\n     * Toggle options\n     */\n    this.toggleOptions = function() {\n      if (this.isShowingOptions) {\n        this.hideOptions();\n      }\n      else {\n        this.showOptions();\n      }\n    };\n\n    /**\n     * Has options check\n     */\n    this.hasOptions = function() {\n      return (this.options.length > 0);\n    };\n\n    /**\n     * Select by input character(s)\n     */\n    this.selectByInput = function(char) {\n\n      //Lowercase all the things\n      char = char.toLowerCase();\n\n      //Add to phrase\n      phrase += char;\n\n      //Create regex\n      const regex = new RegExp('^' + phrase, 'i');\n\n      //Find matching option\n      const option = this.options.find(option => {\n        const label = getLabelValue(option);\n        return String(label).match(regex);\n      });\n\n      //Match found?\n      if (option) {\n        const index = this.options.findIndex(o => o === option);\n        this.select(option, index, true);\n      }\n\n      //Clear phrase (debounced)\n      clearPhrase();\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option, index, leaveOpen) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Hide options\n      if (!leaveOpen) {\n        this.hideOptions();\n      }\n      else {\n        ensureSelectionInView();\n      }\n\n      //Get the new model value and call on change handler\n      let value = getModelValue(option, index);\n      this.onChange({value, option});\n    };\n\n    /**\n     * Set the selection index\n     */\n    this.setSelection = function(index) {\n      selectionIndex = index;\n    };\n\n    /**\n     * Check if given index is the selection index\n     */\n    this.isSelection = function(index) {\n      return (selectionIndex === index);\n    };\n\n    /**\n     * Confirm selection\n     */\n    this.confirmSelection = function(index) {\n\n      //If index not given, use current selection index\n      if (typeof index === 'undefined') {\n        index = selectionIndex;\n      }\n\n      //Initialize option\n      let option;\n\n      //Nullable and -1 index given?\n      if (this.isNullable && index === -1) {\n        option = null;\n      }\n\n      //Otherwise, take from given options\n      else {\n\n        //Validate index\n        if (\n          !this.hasOptions() ||\n          typeof index === 'undefined' ||\n          typeof this.options[index] === 'undefined'\n        ) {\n          return;\n        }\n\n        //Get option\n        option = this.options[index];\n      }\n\n      //Select option now\n      this.select(option, index);\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('TypeAhead.Component', [])\n\n/**\n * Type ahead component\n */\n.component('typeAhead', {\n  template:\n    `<div class=\"TypeAhead {{$ctrl.typeAheadClass}}\">\n      <input class=\"Input {{$ctrl.inputClass}}\" type=\"text\"\n        placeholder=\"{{$ctrl.placeholder}}\"\n        ng-keydown=\"$ctrl.keydown($event)\"\n        ng-keyup=\"$ctrl.keyup($event)\"\n        ng-disabled=\"$ctrl.isDisabled\"\n        ng-model=\"$ctrl.searchQuery\">\n      <spinner class=\"Spinner--input\" ng-if=\"$ctrl.isSearching\"></spinner>\n      <ul class=\"TypeAhead-results\" ng-if=\"$ctrl.isShowingResults\">\n        <li\n          ng-repeat=\"item in $ctrl.results\"\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\n          ng-mouseover=\"$ctrl.setSelection($index)\"\n          ng-click=\"$ctrl.confirmSelection($index)\"\n          ng-transclude>\n          <span ng-bind-html=\"$ctrl.getLabel(item) |\n            markmatches:$ctrl.searchQuery:'strong'\"></span>\n        </li>\n      </ul>\n    </div>`,\n  transclude: true,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    inputClass: '@',\n    options: '<',\n    placeholder: '@',\n    debounce: '<',\n    clearInput: '<',\n    onSearch: '&',\n    onChange: '&',\n    onQuery: '&',\n    isDisabled: '<ngDisabled',\n    labelBy: '@',\n    trackBy: '@',\n    asObject: '@',\n    minLength: '@',\n    allowNew: '@',\n  },\n\n  /**\n   * Component controller\n   */\n  controller(\n    $element, $scope, $formControls, $attrs, $log, $q, $timeout, $document\n  ) {\n\n    //Helper vars\n    let $input;\n    let selectionIndex = -1;\n    const $ctrl = this;\n    const labelBy = $attrs.labelBy || null;\n    const trackBy = $attrs.trackBy || null;\n    const asObject = ($attrs.asObject === 'true');\n    const allowNew = ($attrs.allowNew === 'true');\n\n    //Keep track of searches, prevent older searches overwriting newer ones\n    let currentSearch = 0;\n    let lastProcessedSearch = 0;\n    let pendingSearch = null;\n\n    //Keycodes\n    const ENTER = 13;\n    const ESC = 27;\n    const TAB = 9;\n    const LEFT = 37;\n    const UP = 38;\n    const RIGHT = 39;\n    const DOWN = 40;\n    const SHIFT = 16;\n    const CTRL = 17;\n    const ALT = 18;\n    const CAPSLOCK = 20;\n    const CMDLEFT = 91;\n    const CMDRIGHT = 93;\n\n    /**\n     * Check if input was control\n     */\n    function isControlInput(event) {\n      const keys = [\n        UP, DOWN, LEFT, RIGHT, ENTER, ESC, TAB, SHIFT,\n        CTRL, ALT, CAPSLOCK, CMDLEFT, CMDRIGHT,\n      ];\n      return (keys.indexOf(event.keyCode) > -1);\n    }\n\n    /**\n     * Click handler for document\n     */\n    function documentClickHandler(event) {\n      if (!$input[0].contains(event.target) && $ctrl.isShowingResults) {\n        $scope.$apply($ctrl.hideResults.bind($ctrl));\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    /**\n     * Ensure the selected option is in view\n     */\n    function ensureSelectionInView() {\n\n      //Only if open\n      if (!$ctrl.isShowingResults) {\n        return;\n      }\n\n      //Check index\n      if (!$ctrl.isNullable && selectionIndex < 0) {\n        return;\n      }\n\n      //Find options\n      const $container = $input.next().next();\n      const $options = $container.find('li');\n\n      //Get option now, taking into account the additional nullable element\n      const option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n      if (!option) {\n        return;\n      }\n\n      //Determine container and element top and bottom\n      const cTop = $container[0].scrollTop;\n      const cBottom = cTop + $container[0].clientHeight;\n      const eTop = option.offsetTop;\n      const eBottom = eTop + option.clientHeight;\n\n      //Check if out of view\n      if (eTop < cTop) {\n        $container[0].scrollTop -= (cTop - eTop);\n      }\n      else if (eBottom > cBottom) {\n        $container[0].scrollTop += (eBottom - cBottom);\n      }\n    }\n\n    /**\n     * Move selection up\n     */\n    function moveSelectionUp() {\n      const oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.results.length > 0) {\n          selectionIndex = $ctrl.results.length - 1;\n        }\n      }\n      else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n        selectionIndex--;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Move selection down\n     */\n    function moveSelectionDown() {\n      const oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.results.length > 0) {\n          selectionIndex = 0;\n        }\n      }\n      else if (selectionIndex < ($ctrl.results.length - 1)) {\n        selectionIndex++;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option) {\n\n      //Non object? Track by its value\n      if (option === null || !angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for type ahead');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for type ahead tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option) {\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null || typeof option === 'undefined') {\n        return '';\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for type ahead');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for type ahead label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Find the selected option based on the model value\n     */\n    function findOption(model, options) {\n\n      //Nothing selected or null value selected?\n      if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n        return null;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        if (typeof options[model] !== 'undefined') {\n          return options[model];\n        }\n        return null;\n      }\n\n      //Get the model value\n      const modelValue = getTrackingValue(model, model);\n\n      //Find matching option\n      return options\n        .find((option, index) => {\n          const optionValue = getTrackingValue(option, index);\n          return (modelValue === optionValue);\n        });\n    }\n\n    /**\n     * Do a simple search on object property\n     */\n    function searchOptions(value) {\n      if (!value) {\n        return $q.resolve([]);\n      }\n      const regex = new RegExp('(?:^|\\\\b)(' + value + ')', 'i');\n      const items = $ctrl.options\n        .filter(option => {\n          const label = getLabelValue(option);\n          return regex.test(label);\n        });\n      return $q.resolve(items);\n    }\n\n    /**\n     * Init\n     */\n    this.$onInit = function() {\n\n      //Find some elements\n      $input = $element.find('input');\n\n      //Propagate focus\n      $element.attr('tabindex', -1);\n      $element.on('focus', () => {\n        $input[0].focus();\n      });\n\n      //Propagate classes\n      this.typeAheadClass = $element[0].className;\n      $element[0].className = '';\n\n      //Apply document click handler\n      //NOTE: applied on body, so that it can prevent global $document handlers\n      $document.find('body').on('click', documentClickHandler);\n\n      //Initialize results and flags\n      this.results = [];\n      this.isSearching = false;\n      this.isShowingResults = false;\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.model === null || typeof $ctrl.model === 'undefined') {\n          if (allowNew && $ctrl.searchQuery) {\n            return false;\n          }\n          return true;\n        }\n        return false;\n      };\n    };\n\n    /**\n     * Destroy\n     */\n    this.$onDestroy = function() {\n      $document.find('body').off('click', documentClickHandler);\n    };\n\n    /**\n     * Change handler\n     */\n    this.$onChanges = function(changes) {\n\n      //Clear search query if we get a clear input change\n      //NOTE: This is a small hack to fix the issue we were having with\n      //the whole search query being cleared when the address model was\n      //invalidated. We want to persist the search query if someone types\n      //their address and tries to change it, yet we do need a method of\n      //properly clearing the address input as well, hence this hack.\n      if (changes.clearInput) {\n        this.searchQuery = '';\n      }\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n\n        //Only update search query when we have a model\n        //This is to prevent the input from being cleared when we go and edit\n        if (this.model) {\n          let option;\n          if (angular.isArray(this.options)) {\n            option = findOption(this.model, this.options);\n          }\n          else if (angular.isObject(this.model)) {\n            option = this.model;\n          }\n          if (option) {\n            this.searchQuery = getLabelValue(option);\n          }\n        }\n\n        //Validate model\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Key down handler\n     */\n    this.keydown = function(event) {\n\n      //Arrows up/down, move selection\n      if (this.isShowingResults) {\n        if (event.keyCode === UP) {\n          event.preventDefault();\n          moveSelectionUp();\n        }\n        else if (event.keyCode === DOWN) {\n          event.preventDefault();\n          moveSelectionDown();\n        }\n        else if (event.keyCode === ESC) {\n          event.preventDefault();\n          this.hideResults();\n        }\n        else if (event.keyCode === TAB) {\n          //Don't prevent default\n          this.hideResults();\n        }\n        else if (event.keyCode === ENTER) {\n          event.preventDefault();\n          this.confirmSelection();\n        }\n      }\n\n      //Show options\n      else if (event.keyCode === ENTER) {\n        event.preventDefault();\n        this.showResults();\n      }\n    };\n\n    /**\n     * Key up handler\n     */\n    this.keyup = function(event) {\n\n      //If control input, skip further handling\n      if (isControlInput(event)) {\n        return;\n      }\n\n      //Get search query\n      const value = (this.searchQuery || '').trim();\n\n      //Unchanged search query?\n      if (value === this.lastValue) {\n        return;\n      }\n\n      //Set new value\n      this.lastValue = value;\n\n      //Call event handlers\n      this.onQuery({value});\n      this.onChange({value: null, option: null});\n\n      //Validate and mark as dirty\n      this.ngModel.$validate();\n      this.ngModel.$setDirty();\n\n      //Cancel any old pending search\n      if (pendingSearch) {\n        $timeout.cancel(pendingSearch);\n      }\n\n      //Should we search?\n      if (!this.minLength || value.length >= this.minLength) {\n        this.search(value);\n      }\n      else if (this.hasResults()) {\n        this.clearResults();\n        this.clearSelection();\n      }\n    };\n\n    /**************************************************************************\n     * Search\n     ***/\n\n    /**\n     * Search wrapper\n     */\n    this.search = function(value) {\n\n      //Create new debounced search\n      pendingSearch = $timeout(() => {\n        pendingSearch = null;\n        return this.doSearch(value);\n      }, this.debounce || 250);\n\n      //Return the promise\n      return pendingSearch;\n    };\n\n    /**\n     * Actual search handler\n     */\n    this.doSearch = function(value) {\n\n      //Determine search handler\n      let search;\n      if (this.options && angular.isArray(this.options)) {\n        search = searchOptions(value);\n      }\n      else if ($attrs.onSearch) {\n        search = this.onSearch({value});\n      }\n      else {\n        $log.warn('No search handler or options specified');\n        return $q.reject();\n      }\n\n      //Toggle flag\n      this.isSearching = true;\n\n      //Return search promise\n      return search\n\n        //Check if we've gotten an old search back\n        .then(results => {\n          if (++currentSearch > lastProcessedSearch) {\n            return results;\n          }\n          return $q.reject('old search');\n        })\n\n        //Process the results\n        .then(results => {\n          this.clearSelection();\n          this.results = results;\n          if (results && results.length > 0) {\n            this.isShowingResults = true;\n          }\n          lastProcessedSearch = currentSearch;\n        })\n\n        //Done searching\n        .finally(() => this.isSearching = false);\n    };\n\n    /**************************************************************************\n     * Results navigation & handling\n     ***/\n\n    /**\n     * Check if we have results\n     */\n    this.hasResults = function() {\n      return (this.results && this.results.length > 0);\n    };\n\n    /**\n     * Clear results\n     */\n    this.clearResults = function() {\n      this.results = [];\n      this.isShowingResults = false;\n    };\n\n    /**\n     * Show results\n     */\n    this.showResults = function() {\n      if (this.hasResults()) {\n        this.isShowingResults = true;\n      }\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Hide options\n      this.hideResults();\n\n      //Get the new model and label values\n      const value = getModelValue(option);\n      const label = getLabelValue(option);\n\n      //Set as search query\n      this.searchQuery = label;\n\n      //Call event handlers\n      this.onQuery({value: label});\n      this.onChange({value, option});\n    };\n\n    /**\n     * Hide results\n     */\n    this.hideResults = function() {\n      this.isShowingResults = false;\n    };\n\n    /**\n     * Set the selection index\n     */\n    this.setSelection = function(index) {\n      selectionIndex = index;\n    };\n\n    /**\n     * Check if given index is the selection index\n     */\n    this.isSelection = function(index) {\n      return (selectionIndex === index);\n    };\n\n    /**\n     * Clear selection\n     */\n    this.clearSelection = function() {\n      selectionIndex = undefined;\n    };\n\n    /**\n     * Confirm selection\n     */\n    this.confirmSelection = function(index) {\n\n      //If index not given, use current selection index\n      if (typeof index === 'undefined') {\n        index = selectionIndex;\n      }\n\n      //Validate index\n      if (\n        this.results.length === 0 ||\n        typeof this.results[index] === 'undefined') {\n        return;\n      }\n\n      //Select result\n      this.select(this.results[index]);\n    };\n  },\n});\n\n})(window, window.angular);\n"]}