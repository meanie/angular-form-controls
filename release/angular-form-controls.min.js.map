{"version":3,"sources":["check-box.js","check-boxes.js","form-controls.js","radio-buttons.js","select-box.js","type-ahead.js"],"names":["angular","template","bindings","isInverse","controller","$onInit","$element","on","$ctrl","focus","ngModel","$setDirty","this","onChange","value","isChecked","window","model","options","max","asObject","$attrs","$log","$formControls","option","trackBy","isObject","getLabelValue","warn","labelBy","getTrackingValue","className","classes","isArray","modelValue","$error","required","length","min","allowInvalid","$$setOptions","changes","toggle","index","checked","optionValue","push","i","module","hasChanged","previousValue","equals","currentValue","isNullable","isDisabled","getModelValue","isSelected","nullValue","nullLabel","$validate","select","undefined","inputClass","hasSpinner","$container","event","keyCode","style","$window","getComputedStyle","findOffset","relativeNode","offset","ensureDropdownInView","height","bottom","$parent","scrollTop","cTop","selectionIndex","cBottom","eTop","eBottom","oldIndex","ensureSelectionInView","findOption","phrase","KeyCodes","ENTER","ESC","SPACE","DOWN","func","delay","timeout","wrapper","isTextInput","isShowingOptions","$document","$onChanges","off","documentClickHandler","moveSelectionUp","preventDefault","showOptions","confirmSelection","hideOptions","char","getLabel","toggleOptions","selectByInput","regex","toLowerCase","find","findIndex","o","clearPhrase","setSelection","placeholder","onQuery","minLength","allowNew","$scope","$q","$timeout","label","items","currentSearch","lastProcessedSearch","pendingSearch","typeAheadClass","results","isSearching","searchQuery","keydown","moveSelectionDown","TAB","clearResults","search","doSearch","debounce","searchOptions","reject","then","finally","_this2","isShowingResults","showResults","hideResults","clearSelection"],"mappings":"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","file":"angular-form-controls.min.js","sourcesContent":["(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('CheckBox.Component', [])\n\n/**\n * Checkbox component\n */\n.component('checkBox', {\n  template:\n    `<label class=\"CheckBox\"\n      ng-transclude\n      ng-click=\"$ctrl.toggle($event)\"\n      ng-class=\"{checked: $ctrl.isChecked(), disabled: $ctrl.isDisabled}\"\n    ></label>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  transclude: true,\n  bindings: {\n    model: '<ngModel',\n    onChange: '&',\n    isInverse: '<isInverse',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $formControls) {\n\n    //Get instance\n    let $ctrl = this;\n\n    /**\n     * On init\n     */\n    this.$onInit = function() {\n\n      //Add checkbox wrapper class to parent component\n      $element.addClass('CheckBoxWrapper');\n\n      //Find label\n      const $label = $element.find('label');\n\n      //Propagate focus\n      $element.on('focus', () => {\n        $label[0].focus();\n      });\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isInverse) {\n          return !!$ctrl.model;\n        }\n        return !$ctrl.model;\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Toggle\n     */\n    this.toggle = function(event) {\n\n      //Don't toggle when disabled or event default prevented\n      if (this.isDisabled || event.defaultPrevented) {\n        return;\n      }\n\n      //Get boolean value and call on change handler\n      let value = !this.model;\n      this.onChange({value});\n    };\n\n    /**\n     * Check if checked\n     */\n    this.isChecked = function() {\n      return (this.isInverse ? !this.model : !!this.model);\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('CheckBoxes.Component', [])\n\n/**\n * Checkboxes component\n */\n.component('checkBoxes', {\n  template:\n    `<div class=\"CheckBoxGroup {{$ctrl.classes}}\">\n      <label class=\"CheckBox\"\n        ng-repeat=\"option in $ctrl.options\"\n        ng-click=\"$ctrl.toggle(option, $index)\"\n        ng-class=\"{checked: $ctrl.isChecked(option, $index), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.getLabel(option)}}</label>\n    </div>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    min: '<',\n    max: '<',\n    onChange: '&',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $attrs, $log, $formControls) {\n\n    //Helper vars\n    let $ctrl = this;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for check boxes');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for check box tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for check boxes');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for check box label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Check if a certain option is checked\n     */\n    function isChecked(model, option, index) {\n\n      //Nothing selected?\n      if (!angular.isArray(model) || model.length === 0) {\n        return false;\n      }\n\n      //Get option value\n      let optionValue = getTrackingValue(option, index);\n\n      //See if present in model values\n      let find = model.find(model => {\n        let modelValue = getTrackingValue(model, model);\n        return (modelValue === optionValue);\n      });\n      return (typeof find !== 'undefined');\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track check boxes by index if model is an object');\n        asObject = false;\n      }\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Validation for min/max values\n      this.ngModel.$validators.min = function(modelValue) {\n        if ($ctrl.ngModel.$error.required) {\n          return true;\n        }\n        if (!$ctrl.min || $ctrl.min < 0) {\n          return true;\n        }\n        return (!angular.isArray(modelValue) || modelValue.length >= $ctrl.min);\n      };\n      this.ngModel.$validators.max = function(modelValue) {\n        if ($ctrl.ngModel.$error.required) {\n          return true;\n        }\n        if (!$ctrl.max || $ctrl.max < 0) {\n          return true;\n        }\n        return (!angular.isArray(modelValue) || modelValue.length <= $ctrl.max);\n      };\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n\n        //Needed here to prevent $validate from setting the model to undefined\n        //NOTE: first approach for Angular < 1.6.0\n        if (typeof $ctrl.ngModel.$$setOptions === 'function') {\n          $ctrl.ngModel.$$setOptions({\n            allowInvalid: true,\n          });\n        }\n        else {\n          $ctrl.ngModel.$options = $ctrl.ngModel.$options.createChild({\n            allowInvalid: true,\n          });\n        }\n\n        //Return check now\n        return (!angular.isArray($ctrl.model) || $ctrl.model.length === 0);\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          this.options = this.options.split('\\n');\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Check if given option is checked\n     */\n    this.isChecked = function(option, index) {\n      return isChecked(this.model, option, index);\n    };\n\n    /**\n     * Toggle an option\n     */\n    this.toggle = function(option, index) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Initialize value of our model array\n      let value = [];\n      if (angular.isArray(this.model)) {\n        value = this.model.map(item => item);\n      }\n\n      //Check if currently checked (use source model) and get the item value\n      let checked = isChecked(value, option, index);\n      let optionValue = getTrackingValue(option, index);\n\n      //If checked, remove from target model, otherwise add\n      if (checked) {\n        let i = value.findIndex(model => {\n          let modelValue = getTrackingValue(model, model);\n          return (modelValue === optionValue);\n        });\n        value.splice(i, 1);\n      }\n      else {\n        value.push(asObject ? option : optionValue);\n      }\n\n      //Call on change handler\n      this.onChange({value});\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('FormControls.Component', [\n  'CheckBox.Component',\n  'CheckBoxes.Component',\n  'RadioButtons.Component',\n  'SelectBox.Component',\n  'TypeAhead.Component',\n])\n\n/**\n * Helper service\n */\n.factory('$formControls', function() {\n  return {\n\n    /**\n     * Check if an item value really changed (deep checking with angular.equals)\n     */\n    hasChanged(changes) {\n\n      //Get previous and current value\n      let {previousValue, currentValue} = changes;\n\n      //If unitialized, don't trigger changes\n      if (previousValue === 'UNINITIALIZED_VALUE') {\n        return false;\n      }\n\n      //Check if equals\n      return !angular.equals(previousValue, currentValue);\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('RadioButtons.Component', [])\n\n/**\n * Radio buttons component\n */\n.component('radioButtons', {\n  template:\n    `<div class=\"RadioButtonGroup {{$ctrl.classes}}\">\n      <label class=\"RadioButton\"\n        ng-if=\"$ctrl.isNullable\"\n        ng-click=\"$ctrl.select(null)\"\n        ng-class=\"{checked: $ctrl.isSelected(null), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.nullLabel}}</label>\n      <label class=\"RadioButton\"\n        ng-repeat=\"option in $ctrl.options\"\n        ng-click=\"$ctrl.select(option, $index)\"\n        ng-class=\"{checked: $ctrl.isSelected(option, $index), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.getLabel(option)}}</label>\n    </div>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    onChange: '&',\n    isNullable: '<',\n    nullValue: '<',\n    nullLabel: '<',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $attrs, $log, $formControls) {\n\n    //Helper vars\n    let $ctrl = this;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for radio buttons');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for radio tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option, index) {\n\n      //If nullable and null option given, return null value\n      if ($ctrl.isNullable && option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option, index);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullLabel;\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for selectbox');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for selectbox label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Check if a certain option is selected\n     */\n    function isSelected(option, index) {\n\n      //Nullable and null value selected?\n      if (\n        $ctrl.isNullable &&\n        $ctrl.model === $ctrl.nullValue &&\n        option === null) {\n        return true;\n      }\n\n      //Nothing selected?\n      if ($ctrl.model === null) {\n        return false;\n      }\n\n      //Get the model and option values\n      let modelValue = getTrackingValue($ctrl.model, $ctrl.model);\n      let optionValue = getTrackingValue(option, index);\n\n      //Compare the two\n      return (modelValue === optionValue);\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track radio buttons by index if model is an object');\n        asObject = false;\n      }\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isNullable) {\n          return ($ctrl.model === $ctrl.nullValue);\n        }\n        return (\n          $ctrl.model === null ||\n          $ctrl.model === $ctrl.nullValue ||\n          typeof $ctrl.model === 'undefined'\n        );\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          this.options = this.options.split('\\n');\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Set default null value/label if not set\n      if (typeof this.nullValue === 'undefined') {\n        this.nullValue = null;\n      }\n      if (typeof this.nullLabel === 'undefined') {\n        this.nullLabel = 'None';\n      }\n\n      //Set model to null value if not defined or null\n      if (this.isNullable) {\n        if (this.model === null || typeof this.model === 'undefined') {\n          this.model = this.nullValue;\n        }\n      }\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Check if given option is selected\n     */\n    this.isSelected = function(option, index) {\n      return isSelected(option, index);\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option, index) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Get the new model value and call on change handler\n      let value = getModelValue(option, index);\n      this.onChange({value, option});\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('SelectBox.Component', [])\n\n/**\n * Selectbox component\n */\n.component('selectBox', {\n  template:\n    `<div class=\"SelectBox {{$ctrl.selectBoxClass}}\">\n      <div class=\"InputWrapper is-clickable\" ng-click=\"$ctrl.toggleOptions()\">\n        <div class=\"Caret\"\n          ng-class=\"{disabled: $ctrl.isDisabled}\"\n          ng-click=\"$event.stopPropagation()\"\n          ng-if=\"!$ctrl.hasSpinner\"\n        ></div>\n        <input readonly class=\"Input {{$ctrl.inputClass}}\" type=\"text\"\n          ng-value=\"$ctrl.getSelectedLabel()\"\n          ng-keydown=\"$ctrl.keydown($event)\"\n          ng-class=\"{disabled: ($ctrl.isDisabled || $ctrl.hasSpinner)}\">\n        <spinner class=\"Spinner--input\" ng-if=\"$ctrl.hasSpinner\"></spinner>\n      </div>\n      <ul class=\"SelectBox-options\" ng-show=\"$ctrl.isShowingOptions\">\n        <li\n          ng-if=\"$ctrl.isNullable || !$ctrl.hasOptions()\"\n          ng-class=\"{selected: $ctrl.isSelection(-1)}\"\n          ng-mouseover=\"$ctrl.setSelection(-1)\"\n          ng-click=\"$ctrl.confirmSelection(-1); $event.preventDefault();\"\n        >{{$ctrl.nullLabel}}</li>\n        <li\n          ng-transclude\n          ng-repeat=\"option in $ctrl.options\"\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\n          ng-mouseover=\"$ctrl.setSelection($index)\"\n          ng-click=\"$ctrl.confirmSelection($index); $event.preventDefault();\"\n        >{{$ctrl.getLabel(option)}}</li>\n      </ul>\n    </div>`,\n  transclude: true,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    onChange: '&',\n    isNullable: '<',\n    nullValue: '<',\n    nullLabel: '<',\n    inputClass: '@',\n    isDisabled: '<ngDisabled',\n    hasSpinner: '<hasSpinner',\n  },\n\n  /**\n   * Component controller\n   */\n  controller(\n    $element, $attrs, $log, $formControls, $scope, $document, $timeout, $window\n  ) {\n\n    //Helper vars\n    const $ctrl = this;\n    let selectionIndex, $input, $container;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n    let phrase = '';\n\n    //Keycodes\n    const KeyCodes = {\n      ENTER: 13,\n      ESC: 27,\n      SPACE: 32,\n      UP: 38,\n      DOWN: 40,\n    };\n\n    /**\n     * Debounce helper\n     */\n    function debounce(func, delay) {\n\n      //Timeout placeholder\n      let timeout;\n\n      //Create wrapper function\n      const wrapper = function() {\n\n        //Clear any existing timeout\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n\n        //Create new timeout\n        timeout = setTimeout(() => func(), delay);\n      };\n\n      //Return wrapper function\n      return wrapper;\n    }\n\n    /**\n     * Function to clear the phrase (debounced after 1.5 seconds)\n     */\n    const clearPhrase = debounce(() => {\n      phrase = '';\n    }, 1000);\n\n    /**\n     * Check if input was text\n     */\n    function isTextInput(event) {\n      if (event.keyCode >= 48 && event.keyCode <= 57) {\n        return true;\n      }\n      if (event.keyCode >= 65 && event.keyCode <= 90) {\n        return true;\n      }\n      if (event.keyCode === 32) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Click handler for document\n     */\n    function documentClickHandler(event) {\n      if ($ctrl.isShowingOptions && !$element[0].contains(event.target)) {\n        $scope.$apply($ctrl.hideOptions.bind($ctrl));\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    /**\n     * Find scrollable parent\n     */\n    function findScrollableParent($child) {\n\n      //Get parent\n      const $parent = $child.parent();\n      if ($parent.length === 0) {\n        return null;\n      }\n\n      //Get style\n      const style = $window.getComputedStyle($parent[0]);\n\n      //Find element that has auto overflow or which is the body\n      if ($parent[0].tagName === 'BODY' || style.overflowY === 'auto') {\n        return $parent;\n      }\n\n      //Find next\n      return findScrollableParent($parent);\n    }\n\n    /**\n     * Find offset relative to a certain node\n     */\n    function findOffset(node, relativeNode) {\n      let offset = node.offsetTop;\n      while (node.offsetParent && node.offsetParent !== relativeNode) {\n        node = node.offsetParent;\n        offset += node.offsetTop;\n      }\n      return offset;\n    }\n\n    /**\n     * Ensure the whole dropdown is in view\n     */\n    function ensureDropdownInView() {\n\n      //Find scrollable parent\n      const $parent = findScrollableParent($element);\n      if (!$parent) {\n        return;\n      }\n\n      //Get params\n      const offset = findOffset($container[0], $parent[0]);\n      const height = $parent[0].clientHeight;\n      const scroll = $parent[0].scrollTop;\n      const bottom = offset - scroll + $container[0].clientHeight;\n\n      //Check if it's outside of the height\n      if (bottom > height) {\n        const diff = bottom - height + 16;\n        $parent[0].scrollTop += diff;\n      }\n    }\n\n    /**\n     * Ensure the selected option is in view\n     */\n    function ensureSelectionInView() {\n\n      //Check index\n      if (!$ctrl.isNullable && selectionIndex < 0) {\n        return;\n      }\n\n      //Find options\n      const $options = $container.children();\n\n      //Get option now, taking into account the additional nullable element\n      const option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n      if (!option) {\n        return;\n      }\n\n      //Determine container and element top and bottom\n      const cTop = $container[0].scrollTop;\n      const cBottom = cTop + $container[0].clientHeight;\n      const eTop = option.offsetTop;\n      const eBottom = eTop + option.clientHeight;\n\n      //Check if out of view\n      if (eTop < cTop) {\n        $container[0].scrollTop -= (cTop - eTop);\n      }\n      else if (eBottom > cBottom) {\n        $container[0].scrollTop += (eBottom - cBottom);\n      }\n    }\n\n    /**\n     * Move selection up\n     */\n    function moveSelectionUp() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = $ctrl.options.length - 1;\n        }\n      }\n      else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n        selectionIndex--;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Move selection down\n     */\n    function moveSelectionDown() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = 0;\n        }\n      }\n      else if (selectionIndex < ($ctrl.options.length - 1)) {\n        selectionIndex++;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for select box');\n        return $ctrl.nullValue;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for select box tracking');\n        return $ctrl.nullValue;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option, index) {\n\n      //If nullable and null option given, return null value\n      if ($ctrl.isNullable && option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option, index);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null || typeof option === 'undefined') {\n        return $ctrl.nullLabel;\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for select box');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for select box label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Find the selected option based on the model value\n     */\n    function findOption(model, options) {\n\n      //Nothing selected or null value selected?\n      if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n        return null;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        if (typeof options[model] !== 'undefined') {\n          return options[model];\n        }\n        return null;\n      }\n\n      //Get the model value\n      let modelValue = getTrackingValue(model, model);\n\n      //Find matching option\n      return options\n        .find((option, index) => {\n          let optionValue = getTrackingValue(option, index);\n          return (modelValue === optionValue);\n        });\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track select box by index if model is an object');\n        asObject = false;\n      }\n\n      //Initialize flags\n      this.isShowingOptions = false;\n\n      //Propagate classes\n      this.selectBoxClass = $element[0].className;\n      $element[0].className = '';\n\n      //Find some elements\n      $input = $element.find('input');\n      $container = $input.parent().next();\n\n      //Apply global click handler\n      //NOTE: applied on body, so that it can prevent global $document handlers\n      $document.find('body').on('click', documentClickHandler);\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isNullable) {\n          return ($ctrl.model === $ctrl.nullValue);\n        }\n        return (\n          $ctrl.model === null ||\n          $ctrl.model === $ctrl.nullValue ||\n          typeof $ctrl.model === 'undefined'\n        );\n      };\n    };\n\n    /**\n     * Destroy\n     */\n    this.$onDestroy = function() {\n      $document.find('body').off('click', documentClickHandler);\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          this.options = this.options.split('\\n');\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Set default null value/label if not set\n      if (typeof this.nullValue === 'undefined') {\n        this.nullValue = null;\n      }\n      if (typeof this.nullLabel === 'undefined') {\n        this.nullLabel = '...';\n      }\n\n      //Set model to null value if not defined or null\n      if (this.isNullable) {\n        if (this.model === null || typeof this.model === 'undefined') {\n          this.model = this.nullValue;\n        }\n      }\n\n      //If disabled, hide options\n      if (this.isDisabled) {\n        this.isShowingOptions = false;\n      }\n\n      //Determine selection index\n      let option = findOption(this.model, this.options);\n      selectionIndex = this.options.indexOf(option);\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Keydown handler for input element\n     */\n    this.keydown = function(event) {\n\n      //Move selection up or down\n      if (event.keyCode === KeyCodes.UP) {\n        event.preventDefault();\n        if (this.isShowingOptions) {\n          moveSelectionUp();\n        }\n        else {\n          this.showOptions();\n        }\n      }\n      else if (event.keyCode === KeyCodes.DOWN) {\n        event.preventDefault();\n        if (this.isShowingOptions) {\n          moveSelectionDown();\n        }\n        else {\n          this.showOptions();\n        }\n      }\n\n      //Confirm selection\n      else if (event.keyCode === KeyCodes.ENTER && this.isShowingOptions) {\n        event.preventDefault();\n        this.confirmSelection();\n      }\n\n      //Hide options\n      else if (event.keyCode === KeyCodes.ESC && this.isShowingOptions) {\n        event.preventDefault();\n        this.hideOptions();\n      }\n\n      //Show options\n      else if (event.keyCode === KeyCodes.ENTER && !this.isShowingOptions) {\n        event.preventDefault();\n        this.showOptions();\n      }\n\n      //Text input\n      else if (isTextInput(event)) {\n        const char = String.fromCharCode(event.keyCode);\n        this.selectByInput(char);\n      }\n    };\n\n    /**\n     * Get label value of selected option\n     */\n    this.getSelectedLabel = function() {\n      let option = findOption(this.model, this.options);\n      return getLabelValue(option);\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Show options\n     */\n    this.showOptions = function() {\n      if (!this.isDisabled && !this.hasSpinner) {\n        this.isShowingOptions = true;\n        $timeout(() => {\n          ensureDropdownInView();\n        });\n      }\n    };\n\n    /**\n     * Hide options\n     */\n    this.hideOptions = function() {\n      this.isShowingOptions = false;\n    };\n\n    /**\n     * Toggle options\n     */\n    this.toggleOptions = function() {\n      if (this.isShowingOptions) {\n        this.hideOptions();\n      }\n      else {\n        this.showOptions();\n      }\n    };\n\n    /**\n     * Has options check\n     */\n    this.hasOptions = function() {\n      return (this.options.length > 0);\n    };\n\n    /**\n     * Select by input character(s)\n     */\n    this.selectByInput = function(char) {\n\n      //Lowercase all the things\n      char = char.toLowerCase();\n\n      //Add to phrase\n      phrase += char;\n\n      //Create regex\n      const regex = new RegExp('^' + phrase, 'i');\n\n      //Find matching option\n      const option = this.options.find(option => {\n        const label = getLabelValue(option);\n        return label.match(regex);\n      });\n\n      //Match found?\n      if (option) {\n        const index = this.options.findIndex(o => o === option);\n        this.select(option, index, true);\n      }\n\n      //Clear phrase (debounced)\n      clearPhrase();\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option, index, leaveOpen) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Hide options\n      if (!leaveOpen) {\n        this.hideOptions();\n      }\n      else {\n        ensureSelectionInView();\n      }\n\n      //Get the new model value and call on change handler\n      let value = getModelValue(option, index);\n      this.onChange({value, option});\n    };\n\n    /**\n     * Set the selection index\n     */\n    this.setSelection = function(index) {\n      selectionIndex = index;\n    };\n\n    /**\n     * Check if given index is the selection index\n     */\n    this.isSelection = function(index) {\n      return (selectionIndex === index);\n    };\n\n    /**\n     * Confirm selection\n     */\n    this.confirmSelection = function(index) {\n\n      //If index not given, use current selection index\n      if (typeof index === 'undefined') {\n        index = selectionIndex;\n      }\n\n      //Initialize option\n      let option;\n\n      //Nullable and -1 index given?\n      if (this.isNullable && index === -1) {\n        option = null;\n      }\n\n      //Otherwise, take from given options\n      else {\n\n        //Validate index\n        if (\n          !this.hasOptions() ||\n          typeof index === 'undefined' ||\n          typeof this.options[index] === 'undefined'\n        ) {\n          return;\n        }\n\n        //Get option\n        option = this.options[index];\n      }\n\n      //Select option now\n      this.select(option, index);\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('TypeAhead.Component', [])\n\n/**\n * Type ahead component\n */\n.component('typeAhead', {\n  template:\n    `<div class=\"TypeAhead {{$ctrl.typeAheadClass}}\">\n      <input class=\"Input {{$ctrl.inputClass}}\" type=\"text\"\n        placeholder=\"{{$ctrl.placeholder}}\"\n        ng-keydown=\"$ctrl.keydown($event)\"\n        ng-keyup=\"$ctrl.keyup($event)\"\n        ng-disabled=\"$ctrl.isDisabled\"\n        ng-model=\"$ctrl.searchQuery\">\n      <spinner class=\"Spinner--input\"></spinner>\n      <ul class=\"TypeAhead-results\" ng-show=\"$ctrl.isShowingResults\">\n        <li\n          ng-repeat=\"item in $ctrl.results\"\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\n          ng-mouseover=\"$ctrl.setSelection($index)\"\n          ng-click=\"$ctrl.confirmSelection($index)\"\n          ng-transclude>\n          <span ng-bind-html=\"$ctrl.getLabel(item) |\n            markmatches:$ctrl.searchQuery:'strong'\"></span>\n        </li>\n      </ul>\n    </div>`,\n  transclude: true,\n\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    inputClass: '@',\n    options: '<',\n    placeholder: '@',\n    onSearch: '&',\n    onChange: '&',\n    onQuery: '&',\n    isDisabled: '<ngDisabled',\n    labelBy: '@',\n    trackBy: '@',\n    asObject: '@',\n    minLength: '@',\n    allowNew: '@',\n  },\n\n  /**\n   * Component controller\n   */\n  controller(\n    $element, $scope, $formControls, $attrs, $log, $q, $timeout, $document\n  ) {\n\n    //Helper vars\n    let $input, $container, $options;\n    let $ctrl = this;\n    let selectionIndex = -1;\n    let debounce = 100;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n    let allowNew = ($attrs.allowNew === 'true');\n\n    //Keep track of searches, prevent older searches overwriting newer ones\n    let currentSearch = 0;\n    let lastProcessedSearch = 0;\n    let pendingSearch = null;\n\n    //Keycodes\n    const KeyCodes = {\n      ENTER: 13,\n      ESC: 27,\n      SPACE: 32,\n      TAB: 9,\n      UP: 38,\n      DOWN: 40,\n    };\n\n    /**\n     * Check if input was control\n     */\n    function isControlInput(event) {\n      let keys = [\n        KeyCodes.UP, KeyCodes.DOWN, KeyCodes.ENTER, KeyCodes.ESC, KeyCodes.TAB,\n      ];\n      return (keys.indexOf(event.keyCode) > -1);\n    }\n\n    /**\n     * Click handler for document\n     */\n    function documentClickHandler(event) {\n      if (!$input[0].contains(event.target) && $ctrl.isShowingResults) {\n        $scope.$apply($ctrl.hideResults.bind($ctrl));\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    /**\n     * Ensure the selected option is in view\n     */\n    function ensureSelectionInView() {\n\n      //Check index\n      if (!$ctrl.isNullable && selectionIndex < 0) {\n        return;\n      }\n\n      //Get option now, taking into account the additional nullable element\n      let option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n      if (!option) {\n        return;\n      }\n\n      //Determine container and element top and bottom\n      let cTop = $container[0].scrollTop;\n      let cBottom = cTop + $container[0].clientHeight;\n      let eTop = option.offsetTop;\n      let eBottom = eTop + option.clientHeight;\n\n      //Check if out of view\n      if (eTop < cTop) {\n        $container[0].scrollTop -= (cTop - eTop);\n      }\n      else if (eBottom > cBottom) {\n        $container[0].scrollTop += (eBottom - cBottom);\n      }\n    }\n\n    /**\n     * Move selection up\n     */\n    function moveSelectionUp() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = $ctrl.options.length - 1;\n        }\n      }\n      else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n        selectionIndex--;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Move selection down\n     */\n    function moveSelectionDown() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = 0;\n        }\n      }\n      else if (selectionIndex < ($ctrl.options.length - 1)) {\n        selectionIndex++;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option) {\n\n      //Non object? Track by its value\n      if (option === null || !angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for type ahead');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for type ahead tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option) {\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null || typeof option === 'undefined') {\n        return '';\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for type ahead');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for type ahead label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Find the selected option based on the model value\n     */\n    function findOption(model, options) {\n\n      //Nothing selected or null value selected?\n      if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n        return null;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        if (typeof options[model] !== 'undefined') {\n          return options[model];\n        }\n        return null;\n      }\n\n      //Get the model value\n      let modelValue = getTrackingValue(model, model);\n\n      //Find matching option\n      return options\n        .find((option, index) => {\n          let optionValue = getTrackingValue(option, index);\n          return (modelValue === optionValue);\n        });\n    }\n\n    /**\n     * Do a simple search on object property\n     */\n    function searchOptions(value) {\n      if (!value) {\n        return $q.resolve([]);\n      }\n      let regex = new RegExp('(?:^|\\\\b)(' + value + ')', 'i');\n      let items = $ctrl.options\n        .filter(option => {\n          let label = getLabelValue(option);\n          return regex.test(label);\n        });\n      return $q.resolve(items);\n    }\n\n    /**\n     * Init\n     */\n    this.$onInit = function() {\n\n      //Find some elements\n      $input = $element.find('input');\n      $container = $input.next().next();\n      $options = $container.find('li');\n\n      //Propagate focus\n      $element.attr('tabindex', -1);\n      $element.on('focus', () => {\n        $input[0].focus();\n      });\n\n      //Propagate classes\n      this.typeAheadClass = $element[0].className;\n      $element[0].className = '';\n\n      //Apply document click handler\n      //NOTE: applied on body, so that it can prevent global $document handlers\n      $document.find('body').on('click', documentClickHandler);\n\n      //Initialize results and flags\n      this.results = [];\n      this.isSearching = false;\n      this.isShowingResults = false;\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.model === null || typeof $ctrl.model === 'undefined') {\n          if (allowNew && $ctrl.searchQuery) {\n            return false;\n          }\n          return true;\n        }\n        return false;\n      };\n    };\n\n    /**\n     * Destroy\n     */\n    this.$onDestroy = function() {\n      $document.find('body').off('click', documentClickHandler);\n    };\n\n    /**\n     * Change handler\n     */\n    this.$onChanges = function(changes) {\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n\n        //Only update search query when we have a model\n        //This is to prevent the input from being cleared when we go and edit\n        if (this.model) {\n          let option;\n          if (angular.isArray(this.options)) {\n            option = findOption(this.model, this.options);\n          }\n          else if (angular.isObject(this.model)) {\n            option = this.model;\n          }\n          if (option) {\n            this.searchQuery = getLabelValue(option);\n          }\n        }\n\n        //Validate model\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Key down handler\n     */\n    this.keydown = function(event) {\n\n      //Arrows up/down, move selection\n      if (this.isShowingResults && isControlInput(event)) {\n        if (event.keyCode === KeyCodes.UP) {\n          event.preventDefault();\n          moveSelectionUp();\n        }\n        else if (event.keyCode === KeyCodes.DOWN) {\n          event.preventDefault();\n          moveSelectionDown();\n        }\n        else if (event.keyCode === KeyCodes.ESC) {\n          event.preventDefault();\n          this.hideResults();\n        }\n        else if (event.keyCode === KeyCodes.TAB) {\n          //Don't prevent default\n          this.hideResults();\n        }\n        else if (event.keyCode === KeyCodes.ENTER) {\n          event.preventDefault();\n          this.confirmSelection();\n        }\n      }\n\n      //Show options\n      else if (event.keyCode === KeyCodes.ENTER) {\n        event.preventDefault();\n        this.showResults();\n      }\n    };\n\n    /**\n     * Key up handler\n     */\n    this.keyup = function(event) {\n\n      //If control input, skip further handling\n      if (isControlInput(event)) {\n        return;\n      }\n\n      //Get search query\n      let value = (this.searchQuery || '').trim();\n\n      //Call event handlers\n      this.onQuery({value});\n      this.onChange({value: null, option: null});\n\n      //Validate and mark as dirty\n      this.ngModel.$validate();\n      this.ngModel.$setDirty();\n\n      //Should we search?\n      if (!this.minLength || value.length >= this.minLength) {\n        this.search(value);\n      }\n      else if (this.hasResults()) {\n        this.clearResults();\n        this.clearSelection();\n      }\n    };\n\n    /**************************************************************************\n     * Search\n     ***/\n\n    /**\n     * Search wrapper\n     */\n    this.search = function(value) {\n\n      //Create new debounced search\n      pendingSearch = $timeout(() => {\n        pendingSearch = null;\n        return this.doSearch(value);\n      }, debounce);\n\n      //Return the promise\n      return pendingSearch;\n    };\n\n    /**\n     * Actual search handler\n     */\n    this.doSearch = function(value) {\n\n      //Determine search handler\n      let search;\n      if (this.options && angular.isArray(this.options)) {\n        search = searchOptions(value);\n      }\n      else if ($attrs.onSearch) {\n        search = this.onSearch({value});\n      }\n      else {\n        $log.warn('No search handler or options specified');\n        return $q.reject();\n      }\n\n      //Toggle flag\n      this.isSearching = true;\n\n      //Return search promise\n      return search\n\n        //Check if we've gotten an old search back\n        .then(results => {\n          if (++currentSearch > lastProcessedSearch) {\n            return results;\n          }\n          return $q.reject('old search');\n        })\n\n        //Process the results\n        .then(results => {\n          this.clearSelection();\n          this.results = results;\n          if (results && results.length > 0) {\n            this.isShowingResults = true;\n          }\n        })\n\n        //Done searching\n        .finally(() => this.isSearching = false);\n    };\n\n    /**************************************************************************\n     * Results navigation & handling\n     ***/\n\n    /**\n     * Check if we have results\n     */\n    this.hasResults = function() {\n      return (this.results && this.results.length > 0);\n    };\n\n    /**\n     * Clear results\n     */\n    this.clearResults = function() {\n      this.results = [];\n      this.isShowingResults = false;\n    };\n\n    /**\n     * Show results\n     */\n    this.showResults = function() {\n      if (this.hasResults()) {\n        this.isShowingResults = true;\n      }\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Hide options\n      this.hideResults();\n\n      //Get the new model and label values\n      let value = getModelValue(option);\n      let label = getLabelValue(option);\n\n      //Set as search query\n      this.searchQuery = label;\n\n      //Call event handlers\n      this.onQuery({value: label});\n      this.onChange({value, option});\n    };\n\n    /**\n     * Hide results\n     */\n    this.hideResults = function() {\n      this.isShowingResults = false;\n    };\n\n    /**\n     * Set the selection index\n     */\n    this.setSelection = function(index) {\n      selectionIndex = index;\n    };\n\n    /**\n     * Check if given index is the selection index\n     */\n    this.isSelection = function(index) {\n      return (selectionIndex === index);\n    };\n\n    /**\n     * Clear selection\n     */\n    this.clearSelection = function() {\n      selectionIndex = undefined;\n    };\n\n    /**\n     * Confirm selection\n     */\n    this.confirmSelection = function(index) {\n\n      //If index not given, use current selection index\n      if (typeof index === 'undefined') {\n        index = selectionIndex;\n      }\n\n      //Validate index\n      if (\n        this.results.length === 0 ||\n        typeof this.results[index] === 'undefined') {\n        return;\n      }\n\n      //Select result\n      this.select(this.results[index]);\n    };\n  },\n});\n\n})(window, window.angular);\n"]}