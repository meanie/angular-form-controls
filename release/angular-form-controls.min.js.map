{"version":3,"sources":["check-box.js","check-boxes.js","form-controls.js","radio-buttons.js","select-box.js","type-ahead.js"],"names":["angular","template","bindings","isInverse","controller","$onInit","$element","on","$ctrl","focus","ngModel","$setDirty","this","onChange","value","isChecked","window","model","options","max","asObject","$attrs","$log","$formControls","option","trackBy","isObject","getLabelValue","warn","labelBy","getTrackingValue","className","classes","isArray","modelValue","$error","required","length","min","allowInvalid","$$setOptions","toggle","index","checked","optionValue","push","i","module","hasChanged","previousValue","changes","equals","currentValue","isNullable","isDisabled","getModelValue","isSelected","nullValue","nullLabel","$validate","select","undefined","inputClass","hasSpinner","$scope","$document","$timeout","$window","event","keyCode","style","getComputedStyle","findOffset","relativeNode","offset","ensureDropdownInView","$parent","$container","next","bottom","height","scrollTop","isShowingOptions","$options","children","$input","parent","cTop","selectionIndex","cBottom","eTop","eBottom","oldIndex","ensureSelectionInView","findOption","phrase","KeyCodes","ENTER","ESC","SPACE","DOWN","func","delay","timeout","wrapper","isTextInput","$onChanges","off","documentClickHandler","moveSelectionUp","preventDefault","showOptions","confirmSelection","hideOptions","char","getLabel","toggleOptions","selectByInput","regex","toLowerCase","find","findIndex","String","o","clearPhrase","setSelection","placeholder","onQuery","minLength","allowNew","$q","isShowingResults","label","items","currentSearch","lastProcessedSearch","pendingSearch","UP","RIGHT","attr","typeAheadClass","results","isSearching","searchQuery","keydown","moveSelectionDown","TAB","cancel","hasResults","search","doSearch","_this","debounce","searchOptions","reject","then","finally","clearResults","showResults","hideResults","clearSelection"],"mappings":"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","file":"angular-form-controls.min.js","sourcesContent":["(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('CheckBox.Component', [])\n\n/**\n * Checkbox component\n */\n.component('checkBox', {\n  template:\n    `<label class=\"CheckBox\"\n      ng-transclude\n      ng-click=\"$ctrl.toggle($event)\"\n      ng-class=\"{checked: $ctrl.isChecked(), disabled: $ctrl.isDisabled}\"\n    ></label>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  transclude: true,\n  bindings: {\n    model: '<ngModel',\n    onChange: '&',\n    isInverse: '<isInverse',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $formControls) {\n\n    //Get instance\n    let $ctrl = this;\n\n    /**\n     * On init\n     */\n    this.$onInit = function() {\n\n      //Add checkbox wrapper class to parent component\n      $element.addClass('CheckBoxWrapper');\n\n      //Find label\n      const $label = $element.find('label');\n\n      //Propagate focus\n      $element.on('focus', () => {\n        $label[0].focus();\n      });\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isInverse) {\n          return !!$ctrl.model;\n        }\n        return !$ctrl.model;\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Toggle\n     */\n    this.toggle = function(event) {\n\n      //Don't toggle when disabled or event default prevented\n      if (this.isDisabled || event.defaultPrevented) {\n        return;\n      }\n\n      //Get boolean value and call on change handler\n      let value = !this.model;\n      this.onChange({value});\n    };\n\n    /**\n     * Check if checked\n     */\n    this.isChecked = function() {\n      return (this.isInverse ? !this.model : !!this.model);\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('CheckBoxes.Component', [])\n\n/**\n * Checkboxes component\n */\n.component('checkBoxes', {\n  template:\n    `<div class=\"CheckBoxGroup {{$ctrl.classes}}\">\n      <label class=\"CheckBox\"\n        ng-repeat=\"option in $ctrl.options\"\n        ng-click=\"$ctrl.toggle(option, $index)\"\n        ng-class=\"{checked: $ctrl.isChecked(option, $index), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.getLabel(option)}}</label>\n    </div>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    min: '<',\n    max: '<',\n    onChange: '&',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $attrs, $log, $formControls) {\n\n    //Helper vars\n    let $ctrl = this;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for check boxes');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for check box tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for check boxes');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for check box label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Check if a certain option is checked\n     */\n    function isChecked(model, option, index) {\n\n      //Nothing selected?\n      if (!angular.isArray(model) || model.length === 0) {\n        return false;\n      }\n\n      //Get option value\n      let optionValue = getTrackingValue(option, index);\n\n      //See if present in model values\n      let find = model.find(model => {\n        let modelValue = getTrackingValue(model, model);\n        return (modelValue === optionValue);\n      });\n      return (typeof find !== 'undefined');\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track check boxes by index if model is an object');\n        asObject = false;\n      }\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Validation for min/max values\n      this.ngModel.$validators.min = function(modelValue) {\n        if ($ctrl.ngModel.$error.required) {\n          return true;\n        }\n        if (!$ctrl.min || $ctrl.min < 0) {\n          return true;\n        }\n        return (!angular.isArray(modelValue) || modelValue.length >= $ctrl.min);\n      };\n      this.ngModel.$validators.max = function(modelValue) {\n        if ($ctrl.ngModel.$error.required) {\n          return true;\n        }\n        if (!$ctrl.max || $ctrl.max < 0) {\n          return true;\n        }\n        return (!angular.isArray(modelValue) || modelValue.length <= $ctrl.max);\n      };\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n\n        //Needed here to prevent $validate from setting the model to undefined\n        //NOTE: first approach for Angular < 1.6.0\n        if (typeof $ctrl.ngModel.$$setOptions === 'function') {\n          $ctrl.ngModel.$$setOptions({\n            allowInvalid: true,\n          });\n        }\n        else {\n          $ctrl.ngModel.$options = $ctrl.ngModel.$options.createChild({\n            allowInvalid: true,\n          });\n        }\n\n        //Return check now\n        return (!angular.isArray($ctrl.model) || $ctrl.model.length === 0);\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          const options = this.options.split('\\n');\n          const set = new Set(options);\n          this.options = Array.from(set.values());\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Check if given option is checked\n     */\n    this.isChecked = function(option, index) {\n      return isChecked(this.model, option, index);\n    };\n\n    /**\n     * Toggle an option\n     */\n    this.toggle = function(option, index) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Initialize value of our model array\n      let value = [];\n      if (angular.isArray(this.model)) {\n        value = this.model.map(item => item);\n      }\n\n      //Check if currently checked (use source model) and get the item value\n      let checked = isChecked(value, option, index);\n      let optionValue = getTrackingValue(option, index);\n\n      //If checked, remove from target model, otherwise add\n      if (checked) {\n        let i = value.findIndex(model => {\n          let modelValue = getTrackingValue(model, model);\n          return (modelValue === optionValue);\n        });\n        value.splice(i, 1);\n      }\n      else {\n        value.push(asObject ? option : optionValue);\n      }\n\n      //Call on change handler\n      this.onChange({value});\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('FormControls.Component', [\n  'CheckBox.Component',\n  'CheckBoxes.Component',\n  'RadioButtons.Component',\n  'SelectBox.Component',\n  'TypeAhead.Component',\n])\n\n/**\n * Helper service\n */\n.factory('$formControls', function() {\n  return {\n\n    /**\n     * Check if an item value really changed (deep checking with angular.equals)\n     */\n    hasChanged(changes) {\n\n      //Get previous and current value\n      let {previousValue, currentValue} = changes;\n\n      //If unitialized, don't trigger changes\n      if (previousValue === 'UNINITIALIZED_VALUE') {\n        return false;\n      }\n\n      //Check if equals\n      return !angular.equals(previousValue, currentValue);\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('RadioButtons.Component', [])\n\n/**\n * Radio buttons component\n */\n.component('radioButtons', {\n  template:\n    `<div class=\"RadioButtonGroup {{$ctrl.classes}}\">\n      <label class=\"RadioButton\"\n        ng-if=\"$ctrl.isNullable\"\n        ng-click=\"$ctrl.select(null)\"\n        ng-class=\"{checked: $ctrl.isSelected(null), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.nullLabel}}</label>\n      <label class=\"RadioButton\"\n        ng-repeat=\"option in $ctrl.options\"\n        ng-click=\"$ctrl.select(option, $index)\"\n        ng-class=\"{checked: $ctrl.isSelected(option, $index), disabled: $ctrl.isDisabled}\"\n      >{{$ctrl.getLabel(option)}}</label>\n    </div>`,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    onChange: '&',\n    isNullable: '<',\n    nullValue: '<',\n    nullLabel: '<',\n    isDisabled: '<ngDisabled',\n  },\n\n  /**\n   * Component controller\n   */\n  controller($element, $attrs, $log, $formControls) {\n\n    //Helper vars\n    let $ctrl = this;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for radio buttons');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for radio tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option, index) {\n\n      //If nullable and null option given, return null value\n      if ($ctrl.isNullable && option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option, index);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullLabel;\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for selectbox');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for selectbox label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Check if a certain option is selected\n     */\n    function isSelected(option, index) {\n\n      //Nullable and null value selected?\n      if (\n        $ctrl.isNullable &&\n        $ctrl.model === $ctrl.nullValue &&\n        option === null) {\n        return true;\n      }\n\n      //Nothing selected?\n      if ($ctrl.model === null) {\n        return false;\n      }\n\n      //Get the model and option values\n      let modelValue = getTrackingValue($ctrl.model, $ctrl.model);\n      let optionValue = getTrackingValue(option, index);\n\n      //Compare the two\n      return (modelValue === optionValue);\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track radio buttons by index if model is an object');\n        asObject = false;\n      }\n\n      //Propagate classes\n      this.classes = $element[0].className;\n      $element[0].className = '';\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isNullable) {\n          return ($ctrl.model === $ctrl.nullValue);\n        }\n        return (\n          $ctrl.model === null ||\n          $ctrl.model === $ctrl.nullValue ||\n          typeof $ctrl.model === 'undefined'\n        );\n      };\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          const options = this.options.split('\\n');\n          const set = new Set(options);\n          this.options = Array.from(set.values());\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Set default null value/label if not set\n      if (typeof this.nullValue === 'undefined') {\n        this.nullValue = null;\n      }\n      if (typeof this.nullLabel === 'undefined') {\n        this.nullLabel = 'None';\n      }\n\n      //Set model to null value if not defined or null\n      if (this.isNullable) {\n        if (this.model === null || typeof this.model === 'undefined') {\n          this.model = this.nullValue;\n        }\n      }\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Check if given option is selected\n     */\n    this.isSelected = function(option, index) {\n      return isSelected(option, index);\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option, index) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Get the new model value and call on change handler\n      let value = getModelValue(option, index);\n      this.onChange({value, option});\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('SelectBox.Component', [])\n\n/**\n * Selectbox component\n */\n.component('selectBox', {\n  template:\n    `<div class=\"SelectBox {{$ctrl.selectBoxClass}}\">\n      <div class=\"InputWrapper is-clickable\" ng-click=\"$ctrl.toggleOptions()\">\n        <div class=\"Caret\"\n          ng-class=\"{disabled: $ctrl.isDisabled}\"\n          ng-click=\"$event.stopPropagation(); $ctrl.toggleOptions();\"\n          ng-if=\"!$ctrl.hasSpinner\"\n        ></div>\n        <input readonly class=\"Input {{$ctrl.inputClass}}\" type=\"text\"\n          ng-value=\"$ctrl.getSelectedLabel()\"\n          ng-keydown=\"$ctrl.keydown($event)\"\n          ng-class=\"{disabled: ($ctrl.isDisabled || $ctrl.hasSpinner)}\">\n        <spinner class=\"Spinner--input\" ng-if=\"$ctrl.hasSpinner\"></spinner>\n      </div>\n      <ul class=\"SelectBox-options\" ng-if=\"$ctrl.isShowingOptions\">\n        <li\n          ng-if=\"$ctrl.isNullable || !$ctrl.hasOptions()\"\n          ng-class=\"{selected: $ctrl.isSelection(-1)}\"\n          ng-mouseover=\"$ctrl.setSelection(-1)\"\n          ng-click=\"$ctrl.confirmSelection(-1); $event.preventDefault();\"\n        >{{$ctrl.nullLabel}}</li>\n        <li\n          ng-transclude\n          ng-repeat=\"option in $ctrl.options\"\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\n          ng-mouseover=\"$ctrl.setSelection($index)\"\n          ng-click=\"$ctrl.confirmSelection($index); $event.preventDefault();\"\n        >{{$ctrl.getLabel(option)}}</li>\n      </ul>\n    </div>`,\n  transclude: true,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    options: '<',\n    onChange: '&',\n    isNullable: '<',\n    nullValue: '<',\n    nullLabel: '<',\n    inputClass: '@',\n    isDisabled: '<ngDisabled',\n    hasSpinner: '<hasSpinner',\n  },\n\n  /**\n   * Component controller\n   */\n  controller(\n    $element, $attrs, $log, $formControls, $scope, $document, $timeout, $window\n  ) {\n\n    //Helper vars\n    const $ctrl = this;\n    let selectionIndex, $input;\n    let labelBy = $attrs.labelBy || null;\n    let trackBy = $attrs.trackBy || null;\n    let asObject = ($attrs.asObject === 'true');\n    let phrase = '';\n\n    //Keycodes\n    const KeyCodes = {\n      ENTER: 13,\n      ESC: 27,\n      SPACE: 32,\n      UP: 38,\n      DOWN: 40,\n    };\n\n    /**\n     * Debounce helper\n     */\n    function debounce(func, delay) {\n\n      //Timeout placeholder\n      let timeout;\n\n      //Create wrapper function\n      const wrapper = function() {\n\n        //Clear any existing timeout\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n\n        //Create new timeout\n        timeout = setTimeout(() => func(), delay);\n      };\n\n      //Return wrapper function\n      return wrapper;\n    }\n\n    /**\n     * Function to clear the phrase (debounced after 1.5 seconds)\n     */\n    const clearPhrase = debounce(() => {\n      phrase = '';\n    }, 1000);\n\n    /**\n     * Check if input was text\n     */\n    function isTextInput(event) {\n      if (event.keyCode >= 48 && event.keyCode <= 57) {\n        return true;\n      }\n      if (event.keyCode >= 65 && event.keyCode <= 90) {\n        return true;\n      }\n      if (event.keyCode === 32) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Click handler for document\n     */\n    function documentClickHandler(event) {\n      if ($ctrl.isShowingOptions && !$element[0].contains(event.target)) {\n        $scope.$apply($ctrl.hideOptions.bind($ctrl));\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    /**\n     * Find scrollable parent\n     */\n    function findScrollableParent($child) {\n\n      //Get parent\n      const $parent = $child.parent();\n      if ($parent.length === 0) {\n        return null;\n      }\n\n      //Get style\n      const style = $window.getComputedStyle($parent[0]);\n\n      //Find element that has auto overflow or which is the body\n      if ($parent[0].tagName === 'BODY' || style.overflowY === 'auto') {\n        return $parent;\n      }\n\n      //Find next\n      return findScrollableParent($parent);\n    }\n\n    /**\n     * Find offset relative to a certain node\n     */\n    function findOffset(node, relativeNode) {\n      let offset = node.offsetTop;\n      while (node.offsetParent && node.offsetParent !== relativeNode) {\n        node = node.offsetParent;\n        offset += node.offsetTop;\n      }\n      return offset;\n    }\n\n    /**\n     * Ensure the whole dropdown is in view\n     */\n    function ensureDropdownInView() {\n\n      //Only if open\n      if (!$ctrl.isShowingOptions) {\n        return;\n      }\n\n      //Find scrollable parent\n      const $parent = findScrollableParent($element);\n      if (!$parent) {\n        return;\n      }\n\n      //Get params\n      const $container = $input.parent().next();\n      const offset = findOffset($container[0], $parent[0]);\n      const height = $parent[0].clientHeight;\n      const scroll = $parent[0].scrollTop;\n      const bottom = offset - scroll + $container[0].clientHeight;\n\n      //Check if it's outside of the height\n      if (bottom > height) {\n        const diff = bottom - height + 16;\n        $parent[0].scrollTop += diff;\n      }\n    }\n\n    /**\n     * Ensure the selected option is in view\n     */\n    function ensureSelectionInView() {\n\n      //Only if open\n      if (!$ctrl.isShowingOptions) {\n        return;\n      }\n\n      //Check index\n      if (!$ctrl.isNullable && selectionIndex < 0) {\n        return;\n      }\n\n      //Find options\n      const $container = $input.parent().next();\n      const $options = $container.children();\n\n      //Get option now, taking into account the additional nullable element\n      const option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n      if (!option) {\n        return;\n      }\n\n      //Determine container and element top and bottom\n      const cTop = $container[0].scrollTop;\n      const cBottom = cTop + $container[0].clientHeight;\n      const eTop = option.offsetTop;\n      const eBottom = eTop + option.clientHeight;\n\n      //Check if out of view\n      if (eTop < cTop) {\n        $container[0].scrollTop -= (cTop - eTop);\n      }\n      else if (eBottom > cBottom) {\n        $container[0].scrollTop += (eBottom - cBottom);\n      }\n    }\n\n    /**\n     * Move selection up\n     */\n    function moveSelectionUp() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = $ctrl.options.length - 1;\n        }\n      }\n      else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n        selectionIndex--;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Move selection down\n     */\n    function moveSelectionDown() {\n      let oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.options.length > 0) {\n          selectionIndex = 0;\n        }\n      }\n      else if (selectionIndex < ($ctrl.options.length - 1)) {\n        selectionIndex++;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option, index) {\n\n      //Null value?\n      if (option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        return index;\n      }\n\n      //Non object? Track by its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for select box');\n        return $ctrl.nullValue;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for select box tracking');\n        return $ctrl.nullValue;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option, index) {\n\n      //If nullable and null option given, return null value\n      if ($ctrl.isNullable && option === null) {\n        return $ctrl.nullValue;\n      }\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option, index);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null || typeof option === 'undefined') {\n        return $ctrl.nullLabel;\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for select box');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for select box label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Find the selected option based on the model value\n     */\n    function findOption(model, options) {\n\n      //Nothing selected or null value selected?\n      if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n        return null;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        if (typeof options[model] !== 'undefined') {\n          return options[model];\n        }\n        return null;\n      }\n\n      //Get the model value\n      let modelValue = getTrackingValue(model, model);\n\n      //Find matching option\n      return options\n        .find((option, index) => {\n          let optionValue = getTrackingValue(option, index);\n          return (modelValue === optionValue);\n        });\n    }\n\n    /**\n     * Initialization\n     */\n    this.$onInit = function() {\n\n      //Check configuration\n      if (asObject && trackBy === '$index') {\n        $log.warn('Cannot track select box by index if model is an object');\n        asObject = false;\n      }\n\n      //Initialize flags\n      this.isShowingOptions = false;\n\n      //Propagate classes\n      this.selectBoxClass = $element[0].className;\n      $element[0].className = '';\n\n      //Find input\n      $input = $element.find('input');\n\n      //Apply global click handler\n      //NOTE: applied on body, so that it can prevent global $document handlers\n      $document.find('body').on('click', documentClickHandler);\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.isNullable) {\n          return ($ctrl.model === $ctrl.nullValue);\n        }\n        return (\n          $ctrl.model === null ||\n          $ctrl.model === $ctrl.nullValue ||\n          typeof $ctrl.model === 'undefined'\n        );\n      };\n    };\n\n    /**\n     * Destroy\n     */\n    this.$onDestroy = function() {\n      $document.find('body').off('click', documentClickHandler);\n    };\n\n    /**\n     * On change\n     */\n    this.$onChanges = function(changes) {\n\n      //Must have array as options\n      if (!angular.isArray(this.options)) {\n        if (typeof this.options === 'string') {\n          const options = this.options.split('\\n');\n          const set = new Set(options);\n          this.options = Array.from(set.values());\n        }\n        else {\n          this.options = [];\n        }\n      }\n\n      //Set default null value/label if not set\n      if (typeof this.nullValue === 'undefined') {\n        this.nullValue = null;\n      }\n      if (typeof this.nullLabel === 'undefined') {\n        this.nullLabel = '...';\n      }\n\n      //Set model to null value if not defined or null\n      if (this.isNullable) {\n        if (this.model === null || typeof this.model === 'undefined') {\n          this.model = this.nullValue;\n        }\n      }\n\n      //If disabled, hide options\n      if (this.isDisabled) {\n        this.isShowingOptions = false;\n      }\n\n      //Determine selection index\n      let option = findOption(this.model, this.options);\n      selectionIndex = this.options.indexOf(option);\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Keydown handler for input element\n     */\n    this.keydown = function(event) {\n\n      //Move selection up or down\n      if (event.keyCode === KeyCodes.UP) {\n        event.preventDefault();\n        if (this.isShowingOptions) {\n          moveSelectionUp();\n        }\n        else {\n          this.showOptions();\n        }\n      }\n      else if (event.keyCode === KeyCodes.DOWN) {\n        event.preventDefault();\n        if (this.isShowingOptions) {\n          moveSelectionDown();\n        }\n        else {\n          this.showOptions();\n        }\n      }\n\n      //Confirm selection\n      else if (event.keyCode === KeyCodes.ENTER && this.isShowingOptions) {\n        event.preventDefault();\n        this.confirmSelection();\n      }\n\n      //Hide options\n      else if (event.keyCode === KeyCodes.ESC && this.isShowingOptions) {\n        event.preventDefault();\n        this.hideOptions();\n      }\n\n      //Show options\n      else if (event.keyCode === KeyCodes.ENTER && !this.isShowingOptions) {\n        event.preventDefault();\n        this.showOptions();\n      }\n\n      //Text input\n      else if (isTextInput(event)) {\n        const char = String.fromCharCode(event.keyCode);\n        this.selectByInput(char);\n      }\n    };\n\n    /**\n     * Get label value of selected option\n     */\n    this.getSelectedLabel = function() {\n      let option = findOption(this.model, this.options);\n      return getLabelValue(option);\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Show options\n     */\n    this.showOptions = function() {\n      if (!this.isDisabled && !this.hasSpinner) {\n        this.isShowingOptions = true;\n        $timeout(() => {\n          ensureDropdownInView();\n          ensureSelectionInView();\n        });\n      }\n    };\n\n    /**\n     * Hide options\n     */\n    this.hideOptions = function() {\n      this.isShowingOptions = false;\n    };\n\n    /**\n     * Toggle options\n     */\n    this.toggleOptions = function() {\n      if (this.isShowingOptions) {\n        this.hideOptions();\n      }\n      else {\n        this.showOptions();\n      }\n    };\n\n    /**\n     * Has options check\n     */\n    this.hasOptions = function() {\n      return (this.options.length > 0);\n    };\n\n    /**\n     * Select by input character(s)\n     */\n    this.selectByInput = function(char) {\n\n      //Lowercase all the things\n      char = char.toLowerCase();\n\n      //Add to phrase\n      phrase += char;\n\n      //Create regex\n      const regex = new RegExp('^' + phrase, 'i');\n\n      //Find matching option\n      const option = this.options.find(option => {\n        const label = getLabelValue(option);\n        return String(label).match(regex);\n      });\n\n      //Match found?\n      if (option) {\n        const index = this.options.findIndex(o => o === option);\n        this.select(option, index, true);\n      }\n\n      //Clear phrase (debounced)\n      clearPhrase();\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option, index, leaveOpen) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Hide options\n      if (!leaveOpen) {\n        this.hideOptions();\n      }\n      else {\n        ensureSelectionInView();\n      }\n\n      //Get the new model value and call on change handler\n      let value = getModelValue(option, index);\n      this.onChange({value, option});\n    };\n\n    /**\n     * Set the selection index\n     */\n    this.setSelection = function(index) {\n      selectionIndex = index;\n    };\n\n    /**\n     * Check if given index is the selection index\n     */\n    this.isSelection = function(index) {\n      return (selectionIndex === index);\n    };\n\n    /**\n     * Confirm selection\n     */\n    this.confirmSelection = function(index) {\n\n      //If index not given, use current selection index\n      if (typeof index === 'undefined') {\n        index = selectionIndex;\n      }\n\n      //Initialize option\n      let option;\n\n      //Nullable and -1 index given?\n      if (this.isNullable && index === -1) {\n        option = null;\n      }\n\n      //Otherwise, take from given options\n      else {\n\n        //Validate index\n        if (\n          !this.hasOptions() ||\n          typeof index === 'undefined' ||\n          typeof this.options[index] === 'undefined'\n        ) {\n          return;\n        }\n\n        //Get option\n        option = this.options[index];\n      }\n\n      //Select option now\n      this.select(option, index);\n    };\n  },\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('TypeAhead.Component', [])\n\n/**\n * Type ahead component\n */\n.component('typeAhead', {\n  template:\n    `<div class=\"TypeAhead {{$ctrl.typeAheadClass}}\">\n      <input class=\"Input {{$ctrl.inputClass}}\" type=\"text\"\n        placeholder=\"{{$ctrl.placeholder}}\"\n        ng-keydown=\"$ctrl.keydown($event)\"\n        ng-keyup=\"$ctrl.keyup($event)\"\n        ng-disabled=\"$ctrl.isDisabled\"\n        ng-model=\"$ctrl.searchQuery\">\n      <spinner class=\"Spinner--input\" ng-if=\"$ctrl.isSearching\"></spinner>\n      <ul class=\"TypeAhead-results\" ng-if=\"$ctrl.isShowingResults\">\n        <li\n          ng-repeat=\"item in $ctrl.results\"\n          ng-class=\"{selected: $ctrl.isSelection($index)}\"\n          ng-mouseover=\"$ctrl.setSelection($index)\"\n          ng-click=\"$ctrl.confirmSelection($index)\"\n          ng-transclude>\n          <span ng-bind-html=\"$ctrl.getLabel(item) |\n            markmatches:$ctrl.searchQuery:'strong'\"></span>\n        </li>\n      </ul>\n    </div>`,\n  transclude: true,\n  require: {\n    ngModel: 'ngModel',\n  },\n  bindings: {\n    model: '<ngModel',\n    inputClass: '@',\n    options: '<',\n    placeholder: '@',\n    debounce: '<',\n    onSearch: '&',\n    onChange: '&',\n    onQuery: '&',\n    isDisabled: '<ngDisabled',\n    labelBy: '@',\n    trackBy: '@',\n    asObject: '@',\n    minLength: '@',\n    allowNew: '@',\n  },\n\n  /**\n   * Component controller\n   */\n  controller(\n    $element, $scope, $formControls, $attrs, $log, $q, $timeout, $document\n  ) {\n\n    //Helper vars\n    let $input;\n    let selectionIndex = -1;\n    const $ctrl = this;\n    const labelBy = $attrs.labelBy || null;\n    const trackBy = $attrs.trackBy || null;\n    const asObject = ($attrs.asObject === 'true');\n    const allowNew = ($attrs.allowNew === 'true');\n\n    //Keep track of searches, prevent older searches overwriting newer ones\n    let currentSearch = 0;\n    let lastProcessedSearch = 0;\n    let pendingSearch = null;\n\n    //Keycodes\n    const KeyCodes = {\n      ENTER: 13,\n      ESC: 27,\n      SPACE: 32,\n      TAB: 9,\n      LEFT: 37,\n      UP: 38,\n      RIGHT: 39,\n      DOWN: 40,\n    };\n\n    /**\n     * Check if input was control\n     */\n    function isControlInput(event) {\n      const keys = [\n        KeyCodes.UP, KeyCodes.DOWN, KeyCodes.LEFT, KeyCodes.RIGHT,\n        KeyCodes.ENTER, KeyCodes.ESC, KeyCodes.TAB,\n      ];\n      return (keys.indexOf(event.keyCode) > -1);\n    }\n\n    /**\n     * Click handler for document\n     */\n    function documentClickHandler(event) {\n      if (!$input[0].contains(event.target) && $ctrl.isShowingResults) {\n        $scope.$apply($ctrl.hideResults.bind($ctrl));\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    /**\n     * Ensure the selected option is in view\n     */\n    function ensureSelectionInView() {\n\n      //Only if open\n      if (!$ctrl.isShowingResults) {\n        return;\n      }\n\n      //Check index\n      if (!$ctrl.isNullable && selectionIndex < 0) {\n        return;\n      }\n\n      //Find options\n      const $container = $input.next().next();\n      const $options = $container.find('li');\n\n      //Get option now, taking into account the additional nullable element\n      const option = $options[selectionIndex + ($ctrl.isNullable ? 1 : 0)];\n      if (!option) {\n        return;\n      }\n\n      //Determine container and element top and bottom\n      const cTop = $container[0].scrollTop;\n      const cBottom = cTop + $container[0].clientHeight;\n      const eTop = option.offsetTop;\n      const eBottom = eTop + option.clientHeight;\n\n      //Check if out of view\n      if (eTop < cTop) {\n        $container[0].scrollTop -= (cTop - eTop);\n      }\n      else if (eBottom > cBottom) {\n        $container[0].scrollTop += (eBottom - cBottom);\n      }\n    }\n\n    /**\n     * Move selection up\n     */\n    function moveSelectionUp() {\n      const oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.results.length > 0) {\n          selectionIndex = $ctrl.results.length - 1;\n        }\n      }\n      else if (selectionIndex > ($ctrl.isNullable ? -1 : 0)) {\n        selectionIndex--;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Move selection down\n     */\n    function moveSelectionDown() {\n      const oldIndex = selectionIndex;\n      if (typeof selectionIndex === 'undefined') {\n        if ($ctrl.isNullable) {\n          selectionIndex = -1;\n        }\n        else if ($ctrl.results.length > 0) {\n          selectionIndex = 0;\n        }\n      }\n      else if (selectionIndex < ($ctrl.results.length - 1)) {\n        selectionIndex++;\n      }\n      if (oldIndex !== selectionIndex) {\n        ensureSelectionInView();\n      }\n    }\n\n    /**\n     * Helper to get the tracking value of an option\n     */\n    function getTrackingValue(option) {\n\n      //Non object? Track by its value\n      if (option === null || !angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have tracking property\n      if (!trackBy) {\n        $log.warn('Missing track-by property for type ahead');\n        return null;\n      }\n\n      //Validate property\n      if (typeof option[trackBy] === 'undefined') {\n        $log.warn('Unknown property `' + trackBy + '` for type ahead tracking');\n        return null;\n      }\n\n      //Return the property\n      return option[trackBy];\n    }\n\n    /**\n     * Get the model value\n     */\n    function getModelValue(option) {\n\n      //If returning as object, return the selected option\n      if (asObject) {\n        return option;\n      }\n\n      //Otherwise, return the tracking value of the given option\n      return getTrackingValue(option);\n    }\n\n    /**\n     * Get label value of an option\n     */\n    function getLabelValue(option) {\n\n      //Null value?\n      if (option === null || typeof option === 'undefined') {\n        return '';\n      }\n\n      //Non object? Use its value\n      if (!angular.isObject(option)) {\n        return option;\n      }\n\n      //Must have label property\n      if (!labelBy) {\n        $log.warn('Missing label-by property for type ahead');\n        return '';\n      }\n\n      //Validate property\n      if (typeof option[labelBy] === 'undefined') {\n        $log.warn('Unknown property `' + labelBy + '` for type ahead label');\n        return '';\n      }\n\n      //Return the property\n      return option[labelBy];\n    }\n\n    /**\n     * Find the selected option based on the model value\n     */\n    function findOption(model, options) {\n\n      //Nothing selected or null value selected?\n      if (typeof model === 'undefined' || model === $ctrl.nullValue) {\n        return null;\n      }\n\n      //Tracking by index?\n      if (trackBy === '$index') {\n        if (typeof options[model] !== 'undefined') {\n          return options[model];\n        }\n        return null;\n      }\n\n      //Get the model value\n      const modelValue = getTrackingValue(model, model);\n\n      //Find matching option\n      return options\n        .find((option, index) => {\n          const optionValue = getTrackingValue(option, index);\n          return (modelValue === optionValue);\n        });\n    }\n\n    /**\n     * Do a simple search on object property\n     */\n    function searchOptions(value) {\n      if (!value) {\n        return $q.resolve([]);\n      }\n      const regex = new RegExp('(?:^|\\\\b)(' + value + ')', 'i');\n      const items = $ctrl.options\n        .filter(option => {\n          const label = getLabelValue(option);\n          return regex.test(label);\n        });\n      return $q.resolve(items);\n    }\n\n    /**\n     * Init\n     */\n    this.$onInit = function() {\n\n      //Find some elements\n      $input = $element.find('input');\n\n      //Propagate focus\n      $element.attr('tabindex', -1);\n      $element.on('focus', () => {\n        $input[0].focus();\n      });\n\n      //Propagate classes\n      this.typeAheadClass = $element[0].className;\n      $element[0].className = '';\n\n      //Apply document click handler\n      //NOTE: applied on body, so that it can prevent global $document handlers\n      $document.find('body').on('click', documentClickHandler);\n\n      //Initialize results and flags\n      this.results = [];\n      this.isSearching = false;\n      this.isShowingResults = false;\n\n      //Empty check override in order for ng-required to work properly\n      this.ngModel.$isEmpty = function() {\n        if ($ctrl.model === null || typeof $ctrl.model === 'undefined') {\n          if (allowNew && $ctrl.searchQuery) {\n            return false;\n          }\n          return true;\n        }\n        return false;\n      };\n    };\n\n    /**\n     * Destroy\n     */\n    this.$onDestroy = function() {\n      $document.find('body').off('click', documentClickHandler);\n    };\n\n    /**\n     * Change handler\n     */\n    this.$onChanges = function(changes) {\n\n      //Validate and mark as dirty if needed\n      if (changes.model) {\n\n        //Only update search query when we have a model\n        //This is to prevent the input from being cleared when we go and edit\n        if (this.model) {\n          let option;\n          if (angular.isArray(this.options)) {\n            option = findOption(this.model, this.options);\n          }\n          else if (angular.isObject(this.model)) {\n            option = this.model;\n          }\n          if (option) {\n            this.searchQuery = getLabelValue(option);\n          }\n        }\n\n        //Validate model\n        this.ngModel.$validate();\n        if ($formControls.hasChanged(changes.model)) {\n          this.ngModel.$setDirty();\n        }\n      }\n    };\n\n    /**\n     * Get label value of an option\n     */\n    this.getLabel = function(option) {\n      return getLabelValue(option);\n    };\n\n    /**\n     * Key down handler\n     */\n    this.keydown = function(event) {\n\n      //Arrows up/down, move selection\n      if (this.isShowingResults && isControlInput(event)) {\n        if (event.keyCode === KeyCodes.UP) {\n          event.preventDefault();\n          moveSelectionUp();\n        }\n        else if (event.keyCode === KeyCodes.DOWN) {\n          event.preventDefault();\n          moveSelectionDown();\n        }\n        else if (event.keyCode === KeyCodes.ESC) {\n          event.preventDefault();\n          this.hideResults();\n        }\n        else if (event.keyCode === KeyCodes.TAB) {\n          //Don't prevent default\n          this.hideResults();\n        }\n        else if (event.keyCode === KeyCodes.ENTER) {\n          event.preventDefault();\n          this.confirmSelection();\n        }\n      }\n\n      //Show options\n      else if (event.keyCode === KeyCodes.ENTER) {\n        event.preventDefault();\n        this.showResults();\n      }\n    };\n\n    /**\n     * Key up handler\n     */\n    this.keyup = function(event) {\n\n      //If control input, skip further handling\n      if (isControlInput(event)) {\n        return;\n      }\n\n      //Get search query\n      const value = (this.searchQuery || '').trim();\n\n      //Call event handlers\n      this.onQuery({value});\n      this.onChange({value: null, option: null});\n\n      //Validate and mark as dirty\n      this.ngModel.$validate();\n      this.ngModel.$setDirty();\n\n      //Cancel any old pending search\n      if (pendingSearch) {\n        $timeout.cancel(pendingSearch);\n      }\n\n      //Should we search?\n      if (!this.minLength || value.length >= this.minLength) {\n        this.search(value);\n      }\n      else if (this.hasResults()) {\n        this.clearResults();\n        this.clearSelection();\n      }\n    };\n\n    /**************************************************************************\n     * Search\n     ***/\n\n    /**\n     * Search wrapper\n     */\n    this.search = function(value) {\n\n      //Create new debounced search\n      pendingSearch = $timeout(() => {\n        pendingSearch = null;\n        return this.doSearch(value);\n      }, this.debounce || 250);\n\n      //Return the promise\n      return pendingSearch;\n    };\n\n    /**\n     * Actual search handler\n     */\n    this.doSearch = function(value) {\n\n      //Determine search handler\n      let search;\n      if (this.options && angular.isArray(this.options)) {\n        search = searchOptions(value);\n      }\n      else if ($attrs.onSearch) {\n        search = this.onSearch({value});\n      }\n      else {\n        $log.warn('No search handler or options specified');\n        return $q.reject();\n      }\n\n      //Toggle flag\n      this.isSearching = true;\n\n      //Return search promise\n      return search\n\n        //Check if we've gotten an old search back\n        .then(results => {\n          if (++currentSearch > lastProcessedSearch) {\n            return results;\n          }\n          return $q.reject('old search');\n        })\n\n        //Process the results\n        .then(results => {\n          this.clearSelection();\n          this.results = results;\n          if (results && results.length > 0) {\n            this.isShowingResults = true;\n          }\n          lastProcessedSearch = currentSearch;\n        })\n\n        //Done searching\n        .finally(() => this.isSearching = false);\n    };\n\n    /**************************************************************************\n     * Results navigation & handling\n     ***/\n\n    /**\n     * Check if we have results\n     */\n    this.hasResults = function() {\n      return (this.results && this.results.length > 0);\n    };\n\n    /**\n     * Clear results\n     */\n    this.clearResults = function() {\n      this.results = [];\n      this.isShowingResults = false;\n    };\n\n    /**\n     * Show results\n     */\n    this.showResults = function() {\n      if (this.hasResults()) {\n        this.isShowingResults = true;\n      }\n    };\n\n    /**\n     * Select an option\n     */\n    this.select = function(option) {\n\n      //Ignore when disabled\n      if (this.isDisabled) {\n        return;\n      }\n\n      //Hide options\n      this.hideResults();\n\n      //Get the new model and label values\n      const value = getModelValue(option);\n      const label = getLabelValue(option);\n\n      //Set as search query\n      this.searchQuery = label;\n\n      //Call event handlers\n      this.onQuery({value: label});\n      this.onChange({value, option});\n    };\n\n    /**\n     * Hide results\n     */\n    this.hideResults = function() {\n      this.isShowingResults = false;\n    };\n\n    /**\n     * Set the selection index\n     */\n    this.setSelection = function(index) {\n      selectionIndex = index;\n    };\n\n    /**\n     * Check if given index is the selection index\n     */\n    this.isSelection = function(index) {\n      return (selectionIndex === index);\n    };\n\n    /**\n     * Clear selection\n     */\n    this.clearSelection = function() {\n      selectionIndex = undefined;\n    };\n\n    /**\n     * Confirm selection\n     */\n    this.confirmSelection = function(index) {\n\n      //If index not given, use current selection index\n      if (typeof index === 'undefined') {\n        index = selectionIndex;\n      }\n\n      //Validate index\n      if (\n        this.results.length === 0 ||\n        typeof this.results[index] === 'undefined') {\n        return;\n      }\n\n      //Select result\n      this.select(this.results[index]);\n    };\n  },\n});\n\n})(window, window.angular);\n"]}